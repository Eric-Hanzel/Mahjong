Index: src/main/java/logic/gameStage/PreparatoryStage.java
===================================================================
diff --git a/src/main/java/logic/gameStage/PreparatoryStage.java b/src/main/java/logic/gameStage/PreparatoryStage.java
deleted file mode 100644
--- a/src/main/java/logic/gameStage/PreparatoryStage.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameStage;
-
-public class PreparatoryStage {
-}
Index: src/main/resources/com/example/mahjong/joinGameRoom.fxml
===================================================================
diff --git a/src/main/resources/com/example/mahjong/joinGameRoom.fxml b/src/main/resources/com/example/mahjong/joinGameRoom.fxml
deleted file mode 100644
--- a/src/main/resources/com/example/mahjong/joinGameRoom.fxml	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<?import javafx.scene.layout.*?>
-<?import javafx.scene.control.*?>
-<?import javafx.scene.text.*?>
-<?import javafx.geometry.*?>
-
-<AnchorPane fx:controller="com.example.mahjong.JoinGameRoomController" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="400.0" prefWidth="600.0" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
-    <children>
-        <VBox alignment="CENTER" layoutX="200.0" layoutY="100.0" spacing="20.0">
-            <children>
-                <TextField fx:id="inviteCodeField" promptText="请输入邀请码" />
-                <Button fx:id="joinRoomButton" text="加入房间" onAction="#joinRoom" />
-                <Button fx:id="backButton" text="返回" onAction="#goBack" />
-            </children>
-        </VBox>
-    </children>
-</AnchorPane>
Index: src/main/java/logic/data/LogData.java
===================================================================
diff --git a/src/main/java/logic/data/LogData.java b/src/main/java/logic/data/LogData.java
deleted file mode 100644
--- a/src/main/java/logic/data/LogData.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.data;
-
-public class LogData {
-}
Index: src/main/java/logic/rules/test1.java
===================================================================
diff --git a/src/main/java/logic/rules/test1.java b/src/main/java/logic/rules/test1.java
deleted file mode 100644
--- a/src/main/java/logic/rules/test1.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,35 +0,0 @@
-package logic.rules;
-
-import logic.tiles.BambooTile;
-import logic.tiles.CharacterTile;
-import logic.tiles.DotTile;
-import logic.tiles.HandTile;
-
-public class test1 {
-    public static void main(String[] arg){
-        Rule rule = new Rule();
-        VictoryRule victoryRule = new VictoryRule();
-        HandTile handTile = new HandTile("test");
-        handTile.addTile(new CharacterTile("Character",1,1));
-        handTile.addTile(new CharacterTile("Character",2,2));
-        handTile.addTile(new CharacterTile("Character",3,1));
-        handTile.addTile(new BambooTile("Bamboo",3,2));
-        handTile.addTile(new BambooTile("Bamboo",4,1));
-        handTile.addTile(new BambooTile("Bamboo",5,1));
-        handTile.addTile(new BambooTile("Bamboo",5,1));
-        handTile.addTile(new BambooTile("Bamboo",5,1));
-        handTile.addTile(new DotTile("Dot",7,1));
-        handTile.addTile(new DotTile("Dot",8,2));
-        handTile.addTile(new DotTile("Dot",8,3));
-        handTile.addTile(new DotTile("Dot",9,1));
-        handTile.addTile(new DotTile("Dot",9,1));
-        handTile.addTile(new DotTile("Dot",9,1));
-        System.out.println(rule.getSequenceNumber(handTile.getTileSet()));
-        System.out.println(rule.getTripletNumber(handTile.getTileSet()));
-        System.out.println(rule.getPairNumber(handTile.getTileSet()));
-        System.out.println(rule.getKongNumber(handTile.getTileSet()));
-        System.out.println(victoryRule.bigSingleWait(handTile));
-
-
-    }
-}
Index: src/main/java/logic/data/GetData.java
===================================================================
diff --git a/src/main/java/logic/data/GetData.java b/src/main/java/logic/data/GetData.java
deleted file mode 100644
--- a/src/main/java/logic/data/GetData.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.data;
-
-public class GetData {
-}
Index: src/main/java/logic/gameManagement/EventsListener.java
===================================================================
diff --git a/src/main/java/logic/gameManagement/EventsListener.java b/src/main/java/logic/gameManagement/EventsListener.java
deleted file mode 100644
--- a/src/main/java/logic/gameManagement/EventsListener.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameManagement;
-
-public class EventsListener {
-}
Index: src/main/java/logic/rules/VictoryRule.java
===================================================================
diff --git a/src/main/java/logic/rules/VictoryRule.java b/src/main/java/logic/rules/VictoryRule.java
deleted file mode 100644
--- a/src/main/java/logic/rules/VictoryRule.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,193 +0,0 @@
-package logic.rules;
-
-import logic.tiles.HandTile;
-import logic.tiles.LibraryTile;
-import logic.tiles.Tile;
-
-import java.util.ArrayList;
-
-public class VictoryRule extends Rule{
-    public boolean allTriplets(HandTile handTile){
-        boolean victory = false;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-        if (getTripletNumber(copyHandTile) == 4){
-            for (ArrayList<Tile> tileSet : copyHandTile){
-                tileSet.removeAll(checkTriplet(tileSet));
-            }
-            if (getPairNumber(copyHandTile) == 1){
-                victory = true;
-            }
-        }
-        return victory;
-    }
-
-    public boolean bigSingleWait(HandTile handTile){
-        boolean victory = false;
-        int pair = 1;
-        int nonPair = 4;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-        nonPair = nonPair - getKongNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkKong(tileSet));
-        }
-        nonPair = nonPair - getSequenceNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkSequence(tileSet));
-        }
-        nonPair = nonPair - getTripletNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkTriplet(tileSet));
-        }
-        pair = pair - getPairNumber(copyHandTile);
-        if (pair == 0 && nonPair == 0){
-            victory = true;
-        }
-        return victory;
-    }
-
-    public boolean zhuoWuKui(HandTile handTile) {
-        boolean victory = false;
-        int pair = 1;
-        int nonPair = 4;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-        nonPair = nonPair - getKongNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkKong(tileSet));
-        }
-        nonPair = nonPair - getSequenceNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkSequence(tileSet));
-        }
-        nonPair = nonPair - getTripletNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkTriplet(tileSet));
-        }
-        pair = pair - getPairNumber(copyHandTile);
-        if (pair == 0 && nonPair == 0 && handTile.getEndTile().getType() == "Character" && handTile.getEndTile().getMagnitude() == 5){
-            victory = true;
-        }
-        return victory;
-    }
-
-    public boolean haiDiLaoYue(HandTile handTile, LibraryTile libraryTile){
-        boolean victory = false;
-        if (libraryTile.getTileNumber()==0){
-            int pair = 1;
-            int nonPair = 4;
-            ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-            nonPair = nonPair - getKongNumber(copyHandTile);
-            for (ArrayList<Tile> tileSet : copyHandTile){
-                tileSet.removeAll(checkKong(tileSet));
-            }
-            nonPair = nonPair - getSequenceNumber(copyHandTile);
-            for (ArrayList<Tile> tileSet : copyHandTile){
-                tileSet.removeAll(checkSequence(tileSet));
-            }
-            nonPair = nonPair - getTripletNumber(copyHandTile);
-            for (ArrayList<Tile> tileSet : copyHandTile){
-                tileSet.removeAll(checkTriplet(tileSet));
-            }
-            pair = pair - getPairNumber(copyHandTile);
-            if (pair == 0 && nonPair == 0){
-                victory = true;
-            }
-        }
-        return victory;
-    }
-
-    public boolean yiTiaoLong(HandTile handTile){
-        boolean victory = false;
-        boolean yiTiaoLong = false;
-        int pair = 1;
-        int nonPair = 4;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-
-        if (getSequenceNumber(copyHandTile) >= 3){
-            for (ArrayList<Tile> tileSet : copyHandTile){
-                ArrayList<Tile> checkingTileSet = checkSequence(tileSet);
-                int i = 1;
-                for (Tile tile: checkingTileSet){
-                   if (tile.getMagnitude()==i){
-                       i++;
-                   }
-                }
-                if (i == 10){
-                    yiTiaoLong = true;
-                }
-            }
-        }
-
-        nonPair = nonPair - getKongNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkKong(tileSet));
-        }
-        nonPair = nonPair - getSequenceNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkSequence(tileSet));
-        }
-        nonPair = nonPair - getTripletNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkTriplet(tileSet));
-        }
-        pair = pair - getPairNumber(copyHandTile);
-        if (pair == 0 && nonPair == 0 && yiTiaoLong){
-            victory = true;
-        }
-        return victory;
-    }
-
-
-    public boolean qiDuiZi(HandTile handTile){
-        boolean victory = false;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-        if (getPairNumber(copyHandTile) == 7 && getKongNumber(copyHandTile) == 0 && getTripletNumber(copyHandTile) == 0){
-            victory = true;
-        }
-        return victory;
-    }
-    // 杠
-    public boolean gangShangKaiHua(HandTile handTile){
-        boolean victory = false;
-
-        return victory;
-    }
-
-    public boolean qingYiSe(HandTile handTile){
-        boolean victory = false;
-        boolean qingYiSe = false;
-        int pair = 1;
-        int nonPair = 4;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-
-        if (copyHandTile.size() == 1){
-            qingYiSe = true;
-        }
-
-        nonPair = nonPair - getKongNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkKong(tileSet));
-        }
-        nonPair = nonPair - getSequenceNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkSequence(tileSet));
-        }
-        nonPair = nonPair - getTripletNumber(copyHandTile);
-        for (ArrayList<Tile> tileSet : copyHandTile){
-            tileSet.removeAll(checkTriplet(tileSet));
-        }
-        pair = pair - getPairNumber(copyHandTile);
-        if (pair == 0 && nonPair == 0 && qingYiSe){
-            victory = true;
-        }
-        return victory;
-    }
-    //暗杠
-    public boolean superQiDuiZi(HandTile handTile){
-        boolean victory = false;
-        ArrayList<ArrayList<Tile>> copyHandTile = new ArrayList<ArrayList<Tile>>(handTile.getTileSet());
-        if (getPairNumber(copyHandTile) == 7 && getKongNumber(copyHandTile) == 1 && getTripletNumber(copyHandTile) == 0){
-            victory = true;
-        }
-        return victory;
-    }
-}
Index: src/main/java/logic/tiles/test.java
===================================================================
diff --git a/src/main/java/logic/tiles/test.java b/src/main/java/logic/tiles/test.java
deleted file mode 100644
--- a/src/main/java/logic/tiles/test.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,18 +0,0 @@
-package logic.tiles;
-
-public class test {
-    public static void main(String[] arg){
-
-        LibraryTile libraryTile = new LibraryTile();
-        PlayedTile playedTile = new PlayedTile();
-        HandTile handTile = new HandTile("test");
-        libraryTile.sort();
-        System.out.println(libraryTile.getTileSet());
-        for (int i = 0; i < 14; i++){
-            handTile.addTile(libraryTile.discard());
-        }
-        System.out.println(handTile.getTileSet());
-        handTile.sort();
-        System.out.println(handTile.getTileSet());
-    }
-}
Index: src/main/java/logic/gameStage/RunStage.java
===================================================================
diff --git a/src/main/java/logic/gameStage/RunStage.java b/src/main/java/logic/gameStage/RunStage.java
deleted file mode 100644
--- a/src/main/java/logic/gameStage/RunStage.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameStage;
-
-public class RunStage {
-}
Index: src/main/java/logic/account/LoginIn.java
===================================================================
diff --git a/src/main/java/logic/account/LoginIn.java b/src/main/java/logic/account/LoginIn.java
deleted file mode 100644
--- a/src/main/java/logic/account/LoginIn.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.account;
-
-public class LoginIn {
-}
Index: src/main/java/logic/tiles/HandTile.java
===================================================================
diff --git a/src/main/java/logic/tiles/HandTile.java b/src/main/java/logic/tiles/HandTile.java
deleted file mode 100644
--- a/src/main/java/logic/tiles/HandTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,96 +0,0 @@
-package logic.tiles;
-
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.Objects;
-
-public class HandTile implements TileSet{
-    ArrayList<ArrayList<Tile>> handTile;
-    ArrayList<Tile> character;
-    ArrayList<Tile> bamboo;
-    ArrayList<Tile> dot;
-    ArrayList<Tile> wind;
-    ArrayList<Tile> dragon;
-    ArrayList<Tile> lockedTile;
-
-    Tile endTile;
-
-    String owner;
-
-    public HandTile(String player){
-        handTile = new ArrayList<ArrayList<Tile>>();
-        character = new ArrayList<Tile>();
-        bamboo = new ArrayList<Tile>();
-        dot = new ArrayList<Tile>();
-        wind = new ArrayList<Tile>();
-        dragon = new ArrayList<Tile>();
-        handTile.add(character);
-        handTile.add(bamboo);
-        handTile.add(dot);
-        handTile.add(wind);
-        handTile.add(dragon);
-        lockedTile = new ArrayList<Tile>();
-        owner = player;
-        endTile = null;
-    }
-
-    public void lock(Tile tile){
-        lockedTile.add(tile);
-    }
-
-    public void discard(Tile tile) {
-
-        if (Objects.equals(tile.getType(), "Character")) character.remove(tile);
-        if (Objects.equals(tile.getType(), "Bamboo")) bamboo.remove(tile);
-        if (Objects.equals(tile.getType(), "Dot")) dot.remove(tile);
-        if (Objects.equals(tile.getType(), "East")) wind.remove(tile);
-        if (Objects.equals(tile.getType(), "South")) wind.remove(tile);
-        if (Objects.equals(tile.getType(), "North")) wind.remove(tile);
-        if (Objects.equals(tile.getType(), "West")) wind.remove(tile);
-        if (Objects.equals(tile.getType(), "Red")) dragon.remove(tile);
-        if (Objects.equals(tile.getType(), "Green")) dragon.remove(tile);
-        if (Objects.equals(tile.getType(), "White")) dragon.remove(tile);
-    }
-
-    public void addTile(Tile tile){
-        endTile = tile;
-        if (Objects.equals(tile.getType(), "Character")) character.add(tile);
-        if (Objects.equals(tile.getType(), "Bamboo")) bamboo.add(tile);
-        if (Objects.equals(tile.getType(), "Dot")) dot.add(tile);
-        if (Objects.equals(tile.getType(), "East")) wind.add(tile);
-        if (Objects.equals(tile.getType(), "South")) wind.add(tile);
-        if (Objects.equals(tile.getType(), "North")) wind.add(tile);
-        if (Objects.equals(tile.getType(), "West")) wind.add(tile);
-        if (Objects.equals(tile.getType(), "Red")) dragon.add(tile);
-        if (Objects.equals(tile.getType(), "Green")) dragon.add(tile);
-        if (Objects.equals(tile.getType(), "White")) dragon.add(tile);
-    }
-
-    @Override
-    public void sort(){
-        Comparator<Tile> tilecomparator = Comparator.comparingInt(Tile::getMagnitude);
-        character.sort(tilecomparator);
-        bamboo.sort(tilecomparator);
-        dot.sort(tilecomparator);
-        wind.sort(tilecomparator);
-        dragon.sort(tilecomparator);
-    }
-
-
-    public Tile getEndTile(){
-        return endTile;
-    }
-    @Override
-    public ArrayList<ArrayList<Tile>> getTileSet() {
-        return handTile;
-    }
-
-    @Override
-    public int getTileNumber() {
-        return character.size()+bamboo.size()+dot.size()+wind.size()+dragon.size();
-    }
-
-
-
-
-}
Index: src/main/java/logic/account/SignIn.java
===================================================================
diff --git a/src/main/java/logic/account/SignIn.java b/src/main/java/logic/account/SignIn.java
deleted file mode 100644
--- a/src/main/java/logic/account/SignIn.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.account;
-
-public class SignIn {
-}
Index: src/main/java/logic/tiles/TileSet.java
===================================================================
diff --git a/src/main/java/logic/tiles/TileSet.java b/src/main/java/logic/tiles/TileSet.java
deleted file mode 100644
--- a/src/main/java/logic/tiles/TileSet.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,10 +0,0 @@
-package logic.tiles;
-
-public interface TileSet<T> {
-
-    void sort();
-
-    T getTileSet();
-
-    int getTileNumber();
-}
Index: src/main/java/logic/tiles/LibraryTile.java
===================================================================
diff --git a/src/main/java/logic/tiles/LibraryTile.java b/src/main/java/logic/tiles/LibraryTile.java
deleted file mode 100644
--- a/src/main/java/logic/tiles/LibraryTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,57 +0,0 @@
-package logic.tiles;
-
-import java.util.ArrayList;
-import java.util.Collections;
-
-public class LibraryTile implements TileSet{
-    ArrayList<Tile> tileList;
-    int tileNumber;
-
-    LibraryTile(){
-        tileList = new ArrayList<Tile>();
-        for (int i = 1; i < 10; ++i){
-            for (int j = 1; j < 5; ++j){
-                tileList.add(new CharacterTile("Character",i,j));
-                tileList.add(new BambooTile("Bamboo",i,j));
-                tileList.add(new DotTile("Dot",i,j));
-                if (i == 1) tileList.add(new HonorTile("East",j));
-                if (i == 2) tileList.add(new HonorTile("South",j));
-                if (i == 3) tileList.add(new HonorTile("West",j));
-                if (i == 4) tileList.add(new HonorTile("North",j));
-                if (i == 5) tileList.add(new HonorTile("Red",j));
-                if (i == 6) tileList.add(new HonorTile("Green",j));
-                if (i == 7) tileList.add(new HonorTile("White",j));
-            }
-        }
-        tileNumber = 136;
-    }
-
-    public Tile discard() {
-        Tile tempTile = tileList.get(0);
-        tileList.remove(0);
-        tileNumber--;
-        return tempTile;
-    }
-
-    public Tile discardBack(){
-        tileList.remove(tileNumber-1);
-        tileNumber--;
-        return tileList.get(tileNumber-1);
-    }
-
-    @Override
-    public void sort() {
-        Collections.shuffle(tileList);
-    }
-
-    @Override
-    public ArrayList<Tile> getTileSet() {
-        return tileList;
-    }
-
-    @Override
-    public int getTileNumber() {
-        return tileNumber;
-    }
-
-}
Index: src/main/java/logic/players/Ai.java
===================================================================
diff --git a/src/main/java/logic/players/Ai.java b/src/main/java/logic/players/Ai.java
deleted file mode 100644
--- a/src/main/java/logic/players/Ai.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,94 +0,0 @@
-package logic.players;
-
-import logic.rules.Rule;
-import logic.tiles.HandTile;
-import logic.tiles.Tile;
-
-public class Ai implements GameRole {
-
-    String name;
-    HandTile handTile;
-    boolean dealerState;
-    boolean turnState;
-    boolean readyState;
-    int scoring;
-    Rule rule;
-
-    Ai(String player){
-        name = player;
-        handTile = new HandTile(name);
-        dealerState = false;
-        turnState = false;
-        readyState = false;
-        scoring = 0;
-        rule = new Rule();
-    }
-
-    public void aiAlgorithm(){
-
-    }
-
-    @Override
-    public void discard(Tile tile) {
-        handTile.discard(tile);
-    }
-
-    @Override
-    public void getTile(Tile tile) {
-        handTile.addTile(tile);
-    }
-
-    @Override
-    public void changeDealerState() {
-        dealerState = !dealerState;
-    }
-
-    @Override
-    public void changeTurnState() {
-        turnState = !turnState;
-    }
-
-    @Override
-    public void changeReadyState() {
-        readyState = !readyState;
-    }
-
-
-    //依赖rule
-    @Override
-    public void changeScoring() {
-
-    }
-
-    @Override
-    public HandTile getHandTile() {
-        return handTile;
-    }
-
-    @Override
-    public String getName() {
-        return name;
-    }
-
-    @Override
-    public boolean getDealerState() {
-        return dealerState;
-    }
-
-    @Override
-    public boolean getTurnState() {
-        return turnState;
-    }
-
-    @Override
-    public boolean getReadyState() {
-        return readyState;
-    }
-
-    @Override
-    public int getScoring() {
-        return scoring;
-    }
-
-
-}
Index: src/main/java/logic/players/GameRole.java
===================================================================
diff --git a/src/main/java/logic/players/GameRole.java b/src/main/java/logic/players/GameRole.java
deleted file mode 100644
--- a/src/main/java/logic/players/GameRole.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,33 +0,0 @@
-package logic.players;
-
-import logic.tiles.HandTile;
-import logic.tiles.Tile;
-
-public interface GameRole {
-
-    void discard(Tile tile);
-
-    void getTile(Tile tile);
-
-    void changeDealerState();
-
-    void changeTurnState();
-
-    void changeReadyState();
-
-    void changeScoring();
-
-    HandTile getHandTile();
-
-    String getName();
-
-    boolean getDealerState();
-
-    boolean getTurnState();
-
-    boolean getReadyState();
-
-    int getScoring();
-
-
-}
Index: src/main/java/com/example/mahjong/MenuController.java
===================================================================
diff --git a/src/main/java/com/example/mahjong/MenuController.java b/src/main/java/com/example/mahjong/MenuController.java
deleted file mode 100644
--- a/src/main/java/com/example/mahjong/MenuController.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,55 +0,0 @@
-package com.example.mahjong;
-import javafx.fxml.FXML;
-import javafx.fxml.FXMLLoader;
-import javafx.scene.Scene;
-import javafx.scene.control.Button;
-import javafx.stage.Stage;
-
-import java.io.IOException;
-
-public class MenuController {
-
-    @FXML
-    private Button createRoomButton;
-    @FXML
-    private Button joinRoomButton;
-    @FXML
-    private Button gameRulesButton;
-    @FXML
-    private Button exitGameButton;
-
-
-    @FXML
-    private void handleCreateRoom() throws IOException {
-        // TODO: 跳转到创建房间的页面
-        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("gameRoom.fxml"));
-        Scene gameRuleScene = new Scene(fxmlLoader.load(), 600, 400);
-        // 获取当前窗口并设置新场景
-        Stage primaryStage = (Stage) createRoomButton.getScene().getWindow();
-        primaryStage.setScene(gameRuleScene);
-    }
-
-    @FXML
-    private void handleJoinRoom() {
-        // TODO: 跳转到加入房间的页面
-    }
-
-    @FXML
-    private void handleGameRules() throws IOException {
-        // TODO: 显示游戏规则
-        // 创建游戏主页面的场景和布局
-        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("gameRule.fxml"));
-        Scene gameRuleScene = new Scene(fxmlLoader.load(), 600, 400);
-        // 获取当前窗口并设置新场景
-        Stage primaryStage = (Stage) gameRulesButton.getScene().getWindow();
-        primaryStage.setScene(gameRuleScene);
-    }
-
-    @FXML
-    private void handleExitGame() {
-        // 退出程序
-        Stage stage = (Stage) exitGameButton.getScene().getWindow();
-        stage.close();
-    }
-
-}
Index: src/main/java/com/example/mahjong/LoginController.java
===================================================================
diff --git a/src/main/java/com/example/mahjong/LoginController.java b/src/main/java/com/example/mahjong/LoginController.java
deleted file mode 100644
--- a/src/main/java/com/example/mahjong/LoginController.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,62 +0,0 @@
-package com.example.mahjong;
-
-import javafx.fxml.FXML;
-import javafx.fxml.FXMLLoader;
-import javafx.scene.control.PasswordField;
-import javafx.scene.control.TextField;
-import javafx.scene.control.Alert;
-import javafx.scene.control.Alert.AlertType;
-import javafx.event.ActionEvent;
-import javafx.stage.Stage;
-import javafx.scene.Scene;
-
-import java.io.IOException;
-
-public class LoginController {
-
-    @FXML
-    private TextField usernameField;
-
-    @FXML
-    private PasswordField passwordField;
-
-    @FXML
-    private void handleLogin(ActionEvent event) throws IOException {
-        String username = usernameField.getText();
-        String password = passwordField.getText();
-
-        if (isValidCredentials(username, password)) {
-            // 凭据有效，进入游戏主页面
-            goToGameMenuPage();
-        } else {
-            // 凭据无效，弹出警告并清空输入字段
-            showLoginFailedAlert();
-            usernameField.clear();
-            passwordField.clear();
-        }
-    }
-
-    private boolean isValidCredentials(String username, String password) {
-        // 这里应该有一个更安全的验证机制
-        return "user".equals(username) && "pass".equals(password);
-    }
-
-    private void goToGameMenuPage() throws IOException {
-        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("menu.fxml"));
-        Scene menuScene = new Scene(fxmlLoader.load(), 600, 400);
-        // 创建游戏主页面的场景和布局
-
-        // 获取当前窗口并设置新场景
-        Stage primaryStage = (Stage) usernameField.getScene().getWindow();
-        primaryStage.setScene(menuScene);
-    }
-
-    private void showLoginFailedAlert() {
-        // 创建并显示登录失败的警告
-        Alert alert = new Alert(AlertType.ERROR);
-        alert.setTitle("登录失败");
-        alert.setHeaderText(null);
-        alert.setContentText("用户名或密码错误，请重新输入！");
-        alert.showAndWait();
-    }
-}
Index: src/main/java/logic/gameManagement/Game.java
===================================================================
diff --git a/src/main/java/logic/gameManagement/Game.java b/src/main/java/logic/gameManagement/Game.java
deleted file mode 100644
--- a/src/main/java/logic/gameManagement/Game.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameManagement;
-
-public class Game {
-}
Index: src/main/java/logic/gameStage/EndStage.java
===================================================================
diff --git a/src/main/java/logic/gameStage/EndStage.java b/src/main/java/logic/gameStage/EndStage.java
deleted file mode 100644
--- a/src/main/java/logic/gameStage/EndStage.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameStage;
-
-public class EndStage {
-}
Index: src/main/java/com/example/mahjong/JoinGameRoomController.java
===================================================================
diff --git a/src/main/java/com/example/mahjong/JoinGameRoomController.java b/src/main/java/com/example/mahjong/JoinGameRoomController.java
deleted file mode 100644
--- a/src/main/java/com/example/mahjong/JoinGameRoomController.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,33 +0,0 @@
-package com.example.mahjong;
-import javafx.fxml.FXML;
-import javafx.scene.control.Button;
-import javafx.scene.control.TextField;
-import javafx.event.ActionEvent;
-public class JoinGameRoomController {
-
-    @FXML
-    private TextField inviteCodeField;
-
-    @FXML
-    private Button joinRoomButton;
-
-    @FXML
-    private Button backButton;
-
-    // 当用户点击加入房间按钮时调用此方法
-    @FXML
-    private void joinRoom(ActionEvent event) {
-        String inviteCode = inviteCodeField.getText();
-        // 在这里添加加入房间的逻辑
-        System.out.println("加入房间的邀请码: " + inviteCode);
-        // 例如：roomManager.joinRoom(inviteCode);
-    }
-
-    // 当用户点击返回按钮时调用此方法
-    @FXML
-    private void goBack(ActionEvent event) {
-        // 在这里添加返回上一个界面的逻辑
-        System.out.println("返回上一个界面");
-        // 例如：mainController.showPreviousView();
-    }
-}
Index: src/main/resources/com/example/mahjong/login.fxml
===================================================================
diff --git a/src/main/resources/com/example/mahjong/login.fxml b/src/main/resources/com/example/mahjong/login.fxml
deleted file mode 100644
--- a/src/main/resources/com/example/mahjong/login.fxml	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,24 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<?import javafx.geometry.Insets?>
-<?import javafx.scene.control.Button?>
-<?import javafx.scene.control.Label?>
-<?import javafx.scene.control.PasswordField?>
-<?import javafx.scene.control.TextField?>
-<?import javafx.scene.layout.GridPane?>
-<?import javafx.scene.layout.HBox?>
-<?import javafx.scene.layout.VBox?>
-<?import javafx.scene.text.Text?>
-
-<VBox alignment="CENTER" spacing="10" fx:controller="com.example.mahjong.LoginController" xmlns:fx="http://javafx.com/fxml">
-  <Text text="游戏登录" />
-  <GridPane hgap="10" vgap="10" alignment="CENTER">
-    <Label text="用户名:" GridPane.columnIndex="0" GridPane.rowIndex="0" />
-    <TextField fx:id="usernameField" GridPane.columnIndex="1" GridPane.rowIndex="0" />
-    <Label text="密码:" GridPane.columnIndex="0" GridPane.rowIndex="1" />
-    <PasswordField fx:id="passwordField" GridPane.columnIndex="1" GridPane.rowIndex="1" />
-  </GridPane>
-  <HBox alignment="CENTER">
-    <Button text="登录" fx:id="loginButton" onAction="#handleLogin" />
-  </HBox>
-</VBox>
Index: src/main/resources/com/example/mahjong/menu.fxml
===================================================================
diff --git a/src/main/resources/com/example/mahjong/menu.fxml b/src/main/resources/com/example/mahjong/menu.fxml
deleted file mode 100644
--- a/src/main/resources/com/example/mahjong/menu.fxml	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<?import javafx.scene.control.Button?>
-<?import javafx.scene.layout.VBox?>
-<?import javafx.scene.text.Text?>
-
-<VBox alignment="CENTER" fx:controller="com.example.mahjong.MenuController" spacing="20" xmlns:fx="http://javafx.com/fxml">
-    <Text text="麻将游戏" />
-    <Button text="创建房间" fx:id="createRoomButton" onAction="#handleCreateRoom" />
-    <Button text="加入房间" fx:id="joinRoomButton" onAction="#handleJoinRoom" />
-    <Button text="游戏规则" fx:id="gameRulesButton" onAction="#handleGameRules" />
-    <Button text="退出游戏" fx:id="exitGameButton" onAction="#handleExitGame" />
-</VBox>
Index: src/main/java/logic/gameStage/DirectoryStage.java
===================================================================
diff --git a/src/main/java/logic/gameStage/DirectoryStage.java b/src/main/java/logic/gameStage/DirectoryStage.java
deleted file mode 100644
--- a/src/main/java/logic/gameStage/DirectoryStage.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,28 +0,0 @@
-package logic.gameStage;
-
-import logic.data.GetData;
-import logic.players.Player;
-
-import java.util.ArrayList;
-import java.util.EventListener;
-
-public class DirectoryStage {
-    private ArrayList<Player> playerArrayList;
-    private PreparatoryStage gameMatch;
-    private String gameStage;
-    private EventListener eventListener;
-    private GetData getData;
-
-    public PreparatoryStage creatMatch(){
-        return null;
-
-    }
-
-    public PreparatoryStage joinMatch(){
-        return null;
-
-    }
-
-    public void exitGame(){
-    }
-}
Index: src/main/java/logic/gameManagement/GameScreen.java
===================================================================
diff --git a/src/main/java/logic/gameManagement/GameScreen.java b/src/main/java/logic/gameManagement/GameScreen.java
deleted file mode 100644
--- a/src/main/java/logic/gameManagement/GameScreen.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,4 +0,0 @@
-package logic.gameManagement;
-
-public class GameScreen {
-}
Index: src/main/java/logic/tiles/PlayedTile.java
===================================================================
diff --git a/src/main/java/logic/tiles/PlayedTile.java b/src/main/java/logic/tiles/PlayedTile.java
deleted file mode 100644
--- a/src/main/java/logic/tiles/PlayedTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ /dev/null	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
@@ -1,38 +0,0 @@
-package logic.tiles;
-
-import java.util.ArrayList;
-
-public class PlayedTile implements TileSet{
-    ArrayList<Tile> tileList;
-    int tileNumber;
-
-    PlayedTile(){
-        tileList = new ArrayList<Tile>();
-        tileNumber = 0;
-    }
-
-    public void discard() {
-        tileList.remove(tileNumber-1);
-        tileNumber--;
-    }
-
-    public void addTile(Tile tile){
-        tileList.add(tile);
-        tileNumber++;
-    }
-
-    @Override
-    public void sort() {
-
-    }
-
-    @Override
-    public ArrayList<Tile> getTileSet() {
-        return tileList;
-    }
-
-    @Override
-    public int getTileNumber() {
-        return tileNumber;
-    }
-}
Index: src/main/java/com/mmahjong/server/Server.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mmahjong/server/Server.java b/src/main/java/com/mmahjong/server/Server.java
new file mode 100644
--- /dev/null	(date 1717870887968)
+++ b/src/main/java/com/mmahjong/server/Server.java	(date 1717870887968)
@@ -0,0 +1,363 @@
+package com.mmahjong.server;
+
+import logic.games.Game;
+import logic.players.Player;
+import logic.rules.PlayerOperateCheckRule;
+import logic.rules.ScoringRule;
+import logic.rules.VictoryCheckRule;
+
+import java.io.*;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.*;
+import java.util.logging.Logger;
+
+public class Server {
+    public static final Logger logger = Logger.getLogger(Server.class.getName());
+    private static ServerSocket serverSocket;
+    private static final ArrayList<Socket> onLineSocket = new ArrayList<>();
+    private static final ArrayList<ObjectOutputStream> outputs = new ArrayList<>();
+
+    private static logic.games.Game game;
+
+    public static int skipNumber = 0;
+    public static volatile boolean gameStart = false;
+
+    public static void main(String[] args) throws IOException {
+        // Initialize the server socket to listen on port 8888
+        serverSocket = new ServerSocket(8888);
+        logger.info("-------Server started, waiting for clients to connect...------");
+
+        // accept client connections
+        acceptClients();
+    }
+    private static void acceptClients(){
+        logger.info("------Server connection thread started------");
+        while (true) {
+            try {
+                // Accept a new client connection
+                Socket socket = serverSocket.accept();
+                synchronized (onLineSocket) {
+                    // If the number of connected clients exceeds 4, reject the connection
+                    if (onLineSocket.size() >= 4) {
+                        logger.info("------Maximum number of client connections reached, rejecting connection------");
+                        socket.close();
+                        continue;
+                    }
+                    // Add the new client socket to the list of online sockets
+                    onLineSocket.add(socket);
+                }
+                // Create an ObjectOutputStream for the new client
+                ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
+                synchronized (outputs) {
+                    // Add the ObjectOutputStream to the list of output streams
+                    outputs.add(oos);
+                }
+
+                logger.info("------Client connected------" + socket.getRemoteSocketAddress());
+                logger.info("------Current online clients------" + onLineSocket.size());
+                logger.info("------Current online client output streams------" + outputs.size());
+
+                // Start a new thread to handle communication with the new client
+                new HandleClient(socket, socket.getRemoteSocketAddress().toString()).start();
+
+                // If 4 clients are connected, start the game
+                if (onLineSocket.size() == 4) {
+                    synchronized (outputs) {
+                        for (ObjectOutputStream oots : outputs) {
+                            oots.writeUTF("GameStart");
+                            oots.flush();
+                        }
+                    }
+                    game = new Game();
+                    game.gameInit(onLineSocket);
+                    gameStart = true;
+                    logger.info("------Game started------");
+
+                    // Send the initialized player list to all clients
+                    synchronized (outputs) {
+                        for (ObjectOutputStream ooss : outputs) {
+                            ArrayList<logic.players.Player> players = new ArrayList<>(game.getPlayerList());
+                            ooss.reset();
+                            ooss.writeObject(players);
+                            ooss.flush();
+                        }
+                    }
+                    logger.info("------Player list initialized and sent to all clients------");
+                    logger.info("------Player list------" + game.getPlayerList());
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+
+    // Thread class to handle communication with a specific client
+    private static class HandleClient extends Thread {
+        private volatile boolean running = true;
+        private Socket client;
+        private String clientId;
+        private ObjectInputStream input;
+        private VictoryCheckRule victoryCheckRule;
+        private ScoringRule scoringRule;
+
+        public HandleClient(Socket client, String clientId) {
+            logger.info(client + "------Client started successfully------");
+            victoryCheckRule = VictoryCheckRule.getInstance();
+            scoringRule = logic.rules.ScoringRule.getInstance();
+
+            this.client = client;
+            this.clientId = clientId;
+            try {
+                // Create an ObjectInputStream for the client
+                this.input = new ObjectInputStream(client.getInputStream());
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        @Override
+        public void run() {
+            try {
+                while (running) {
+                    System.out.println("------Current player information------");
+                    if (game != null) {
+                        game.printAllPlayersDetails();
+                    }
+                    logger.info(client + "------Waiting for client message------");
+
+                    // Read the message from the client
+                    Object message = input.readObject();
+
+                    if (message instanceof String) {
+                        String operate = (String) message;
+                        logger.info(clientId + "------Received operation----" + message);
+
+                        // Handle client disconnect
+                        if (operate.equals("Disconnect")) {
+                            handleDisconnect();
+                            break; // Exit loop, end thread
+                        }
+
+                        // Handle game operations
+                        if (game != null) {
+                            if (game.getCheckState()) {
+                                logger.info("------Checking phase for Kong/Chow------");
+                                checkStateCommunication(operate);
+                            } else {
+                                logger.info("------Player operation phase------");
+                                nonCheckStateCommunication(operate);
+                            }
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Stop the thread
+        private void stopThread() {
+            running = false;
+            try {
+                client.close();
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Handle client disconnect
+        private void handleDisconnect() throws IOException {
+            game = null;
+            gameStart = false;
+            logger.info(clientId + "------Client disconnected------");
+            synchronized (onLineSocket) {
+                int index = onLineSocket.indexOf(client);
+                outputs.get(index).close();
+                outputs.remove(index);
+                onLineSocket.remove(index);
+            }
+            logger.info("------Current online clients------" + onLineSocket.size());
+            input.close();
+
+            logger.info("------Current online client output streams------" + outputs.size());
+            client.close();
+            stopThread();
+        }
+
+        // Handle communication during the checking phase for Kong/Chow
+        private void checkStateCommunication(String operate) {
+            if (PlayerOperateCheckRule.checkOperateLegal(clientId, operate, game)) {
+                logger.info("------Valid operation------" + operate);
+                checkStateLegalResponse(operate);
+            } else {
+                logger.info("------Invalid operation------" + operate);
+                illegalResponse();
+            }
+        }
+
+        // Handle communication during the normal player operation phase
+        private void nonCheckStateCommunication(String operate) {
+            if (PlayerOperateCheckRule.checkOperateLegal(clientId, operate, game)) {
+                logger.info("------Valid operation------" + operate);
+                nonCheckStateLegalResponse(operate);
+            } else {
+                logger.info("------Invalid operation------" + operate);
+                illegalResponse();
+            }
+        }
+
+        // Handle valid operations during the checking phase
+        private void checkStateLegalResponse(String operate) {
+            Player player = findOperaterPlayer();
+            // Increase skip count if the player skips
+            if (Objects.equals(operate, "Skip") && !player.getSkip()) {
+                skipNumber++;
+                logger.info("------Skip count increased------" + skipNumber);
+            }
+
+            String operateResult = game.logicOperate(clientId, operate);
+            logger.info("------Check phase operation result------" + operateResult);
+            skipResponse(player, operateResult);
+            gameOverResponse(player);
+            ArrayList<Player> players = new ArrayList<>(game.getPlayerList());
+            sendToAllClient(players);
+        }
+
+        // Handle valid operations during the normal player operation phase
+        private void nonCheckStateLegalResponse(String operate) {
+            Player player = findOperaterPlayer();
+            String operateResult = game.logicOperate(clientId, operate);
+            logger.info("------Player operation phase result------" + operateResult);
+            chowResponse(player, operate, operateResult);
+            gameOverResponse(player);
+            ArrayList<Player> players = new ArrayList<>(game.getPlayerList());
+            sendToAllClient(players);
+        }
+
+        // Send an illegal operation response to the client
+        private void illegalResponse() {
+            sendToOneClient(client, "illegal");
+        }
+
+        // Find the player object associated with the client
+        private Player findOperaterPlayer() {
+            logger.info("------Finding player------");
+            Player player = null;
+            for (Player p : game.getPlayerList()) {
+                if (Objects.equals(p.getName(), clientId)) {
+                    player = p;
+                    return player;
+                }
+            }
+            return null;
+        }
+
+        // Send a game over response to all clients
+        private void gameOverResponse(Player player) {
+            if (!game.getGameState()) {
+                logger.info("------Game over, updating status to all clients------");
+                ArrayList<Player> players = new ArrayList<>(game.getPlayerList());
+                scoringRule.getScoring(PlayerOperateCheckRule.checkAllVictoryConditions(game, player, victoryCheckRule, ""), game, players);
+                sendToAllClient("GameOver");
+                sendToAllClient(players);
+                sendToAllClient("Hu " + player.getName() + " " + PlayerOperateCheckRule.checkAllVictoryConditions(game, player, victoryCheckRule, ""));
+            }
+        }
+
+        // Handle skip responses
+        private void skipResponse(Player player, String operateResult) {
+            // Reply to the client
+            if (Objects.equals(operateResult, "Skip")) {
+                sendToOneClient(client, "skipAccept");
+                // Reset if three players have skipped
+                if (skipNumber == 3) {
+                    logger.info("------Check phase ended------Three players skipped");
+                    game.resetAllSkip();
+                    skipNumber = 0;
+                    game.setCheckState(false);
+                    game.changePlayer();
+                    sendToAllClient("checkStateOver");
+                }
+            }
+        }
+
+        // Handle chow responses
+        private void chowResponse(Player player, String operate, String operateResult) {
+            if (Objects.equals(operateResult, "Chow")) {
+                String chowTypes = PlayerOperateCheckRule.getCanChowTypes(player, game.getEndPlayerDiscardTile());
+                logger.info("------Player chow types------" + chowTypes);
+                sendToOneClient(client, chowTypes);
+            }
+        }
+
+        // Send a message to a specific client
+        private void sendToOneClient(Socket socket, String string) {
+            try {
+                logger.info("------Replying to single client------" + socket.getRemoteSocketAddress() + "------" + string);
+                String[] parts = string.split(" ");
+                for (Socket socket1 : onLineSocket) {
+                    if (socket == socket1) {
+                        ObjectOutputStream oos = outputs.get(onLineSocket.indexOf(socket));
+                        if (string.equals("illegal")) {
+                            oos.reset();
+                            oos.writeObject("!!!!!!Illegal operation!!!!!!Prohibited!!!!!!");
+                            oos.flush();
+                            logger.info("Player performed an illegal operation");
+                        } else if (string.equals("skipAccept")) {
+                            oos.reset();
+                            oos.writeObject("skipAccept");
+                            oos.flush();
+                            logger.info("skipAccept");
+                        } else if (string.equals("checkStateOver")) {
+                            oos.reset();
+                            oos.writeObject("checkStateOver");
+                            oos.flush();
+                            logger.info("checkStateOver");
+                        } else if (Objects.equals(parts[0], "chowTypes")) {
+                            oos.reset();
+                            oos.writeObject(string);
+                            oos.flush();
+                            logger.info("Chow types sent to client" + string);
+                        }
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Send a player list to all clients
+        private void sendToAllClient(ArrayList<Player> playerList) {
+            try {
+                synchronized (outputs) {
+                    for (ObjectOutputStream oos : outputs) {
+                        oos.reset();
+                        oos.writeObject(playerList);
+                        oos.flush();
+                    }
+                }
+                logger.info("------Updating all clients with player list------");
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+
+        // Send a string message to all clients
+        private void sendToAllClient(String s) {
+            try {
+                synchronized (outputs) {
+                    for (ObjectOutputStream oos : outputs) {
+                        oos.reset();
+                        oos.writeObject(s);
+                        oos.flush();
+                    }
+                }
+                logger.info("------Updating all clients with game status------" + s);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+}
Index: src/main/java/com/mahjong/client/WaitRoomController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mahjong/client/WaitRoomController.java b/src/main/java/com/mahjong/client/WaitRoomController.java
new file mode 100644
--- /dev/null	(date 1717883284171)
+++ b/src/main/java/com/mahjong/client/WaitRoomController.java	(date 1717883284171)
@@ -0,0 +1,98 @@
+package com.mahjong.client;
+
+import javafx.application.Platform;
+import javafx.fxml.FXML;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.control.Button;
+import javafx.scene.image.Image;
+import javafx.scene.layout.*;
+import javafx.stage.Stage;
+
+import java.io.*;
+import java.net.Socket;
+
+public class WaitRoomController {
+
+    public VBox vBox;
+    @FXML
+    private Button returnButton;
+
+    private Socket socket;
+    private ObjectInputStream input;
+    private ObjectOutputStream output;
+    @FXML
+    public void initialize() {
+        Image backgroundImage = new Image(getClass().getResource("/images/backGround.png").toExternalForm());
+        BackgroundImage background = new BackgroundImage(backgroundImage,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
+                new BackgroundSize(100, 100, true, true, false, true)); // 调整BackgroundSize的参数以覆盖整个VBox
+        vBox.setBackground(new Background(background));
+    }
+
+    // Constructor to initialize socket connection to the server
+    public WaitRoomController() throws IOException {
+        socket = new Socket("localhost", 8888);
+        output = new ObjectOutputStream(socket.getOutputStream());
+        input = new ObjectInputStream(socket.getInputStream());
+        System.out.println("Client connected");
+    }
+
+    // Set socket and initialize streams
+    public void setSocket(Socket socket) throws IOException {
+        this.socket = socket;
+        output = new ObjectOutputStream(this.socket.getOutputStream());
+        input = new ObjectInputStream(this.socket.getInputStream());
+    }
+
+    // Initialize network communication and handle server messages
+    public void initializeNet(Stage stage) {
+        new Thread(() -> {
+            try {
+                while (true) {
+                    String msg = input.readUTF();
+                    if (msg.equals("GameStart")) {
+                        Platform.runLater(() -> {
+                            try {
+                                // Load the game interface
+                                FXMLLoader loader = new FXMLLoader(getClass().getResource("gameRoom.fxml"));
+                                Scene gameScene = new Scene(loader.load(), 1000, 1000);
+                                stage.setScene(gameScene);
+                                // Pass network connection to the game controller
+                                GameRoomController controller = loader.getController();
+                                controller.setNetwork(socket, input, output);
+                            } catch (IOException e) {
+                                e.printStackTrace();
+                            }
+                        });
+                        break;
+                    }
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }).start();
+    }
+
+    // Handle disconnecting from the server
+    @FXML
+    private void handleReturn() throws IOException {
+        // Send disconnect message to the server
+        output.reset();
+        output.writeObject("Disconnect");
+        output.flush();
+
+        // Close the socket
+        output.close();
+        socket.close();
+
+        // Load the main menu scene and layout
+        FXMLLoader loader = new FXMLLoader(getClass().getResource("menu.fxml"));
+        Scene menuScene = new Scene(loader.load(), 1000, 1000);
+
+        // Get the current window and set the new scene
+        Stage stage = (Stage) returnButton.getScene().getWindow();
+        stage.setScene(menuScene);
+    }
+}
+
Index: src/main/resources/com/mahjong/client/overRoom.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/com/mahjong/client/overRoom.fxml b/src/main/resources/com/mahjong/client/overRoom.fxml
new file mode 100644
--- /dev/null	(date 1717879464584)
+++ b/src/main/resources/com/mahjong/client/overRoom.fxml	(date 1717879464584)
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.geometry.Insets?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.Label?>
+<?import javafx.scene.layout.HBox?>
+<?import javafx.scene.layout.VBox?>
+
+<VBox fx:id="vBox" alignment="CENTER" spacing="10" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/21" fx:controller="com.mahjong.client.OverRoomController">
+    <Label fx:id="gameOverLabel" style="-fx-font-size: 24px; -fx-font-weight: bold;" text="游戏结束" />
+    <Label fx:id="scoringLabel" style="-fx-font-size: 18px;" />
+    <Label fx:id="playerNameLabel" style="-fx-font-size: 18px;" />
+    <Label fx:id="victoryTypeLabel" style="-fx-font-size: 18px;" />
+    <Label fx:id="playerHandLabel" style="-fx-font-size: 18px;" />
+    <HBox fx:id="showVictoryTiles" alignment="CENTER" spacing="10">
+        <padding>
+            <Insets bottom="10" left="10" right="10" top="10" />
+        </padding>
+    </HBox>
+    <Button onAction="#continueGame" style="-fx-font-size: 14px;" text="Continue" />
+    <Button onAction="#exitGame" prefHeight="29.0" prefWidth="78.0" style="-fx-font-size: 14px;" text="Exit" />
+</VBox>
Index: src/main/java/com/mahjong/client/GameRulesController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mahjong/client/GameRulesController.java b/src/main/java/com/mahjong/client/GameRulesController.java
new file mode 100644
--- /dev/null	(date 1717885168642)
+++ b/src/main/java/com/mahjong/client/GameRulesController.java	(date 1717885168642)
@@ -0,0 +1,71 @@
+package com.mahjong.client;
+
+import javafx.fxml.FXML;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.control.Button;
+import javafx.scene.control.TextArea;
+import javafx.scene.image.Image;
+import javafx.scene.layout.*;
+import javafx.stage.Stage;
+
+import java.io.IOException;
+
+public class GameRulesController extends Client {
+
+    public VBox rulesVBox;
+    public TextArea rulesTextArea;
+    @FXML
+    private Button returnButton;
+
+    // Constructor for GameRulesController
+    public GameRulesController() throws IOException {
+    }
+    @FXML
+    public void initialize() {
+        Image backgroundImage = new Image(getClass().getResource("/images/backGround.png").toExternalForm());
+        BackgroundImage background = new BackgroundImage(backgroundImage,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
+                new BackgroundSize(100, 100, true, true, false, true)); // 调整BackgroundSize的参数以覆盖整个VBox
+        rulesVBox.setBackground(new Background(background));
+
+        String rules = "Winning Rules:\n" +
+                "1) Basic Requirements:\n" +
+                "   A winning hand must include at least one set of triples and a sequence and must have a pair.\n\n" +
+                "2) Ways to Win:\n" +
+                "   Players can win by either discarding a tile that allows another player to win or by drawing a winning tile themselves.\n\n" +
+                "3) Special Winning Conditions:\n" +
+                "   - Seven Pairs:\n" +
+                "     The hand consists of seven different pairs, without any triples or sequences.\n" +
+                "   - Dragon Seven Pairs:\n" +
+                "     Seven pairs where at least one of the pairs consists of four identical tiles, with the rest being pairs.\n" +
+                "   - Pure Hand:\n" +
+                "     All tiles in the hand are of the same suit.\n" +
+                "   - All Pongs:\n" +
+                "     The hand consists of four sets of triples and one pair.\n" +
+                "   - Winning from a Kong:\n" +
+                "     Winning by drawing a tile after declaring a kong.\n" +
+                "   - Last Tile Win:\n" +
+                "     Winning by drawing the last tile from the wall.\n" +
+                "   - Heavenly Hand:\n" +
+                "     The dealer wins with the initial hand before discarding.\n" +
+                "   - Earthly Hand:\n" +
+                "     A non-dealer player wins off the first tile discarded by the dealer.";
+
+        rulesTextArea.setText(rules);
+
+    }
+
+    @FXML
+    private void handleReturn() throws IOException {
+        // Handle returning to the previous page logic
+        // Load and display the previous page
+        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("menu.fxml"));
+        Scene menuScene = new Scene(fxmlLoader.load(), 1000, 1000);
+
+        // Get the current window and set the new scene
+        Stage stage = (Stage) returnButton.getScene().getWindow();
+        stage.setScene(menuScene);
+    }
+}
+
Index: src/main/java/com/mahjong/client/GameRoomController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mahjong/client/GameRoomController.java b/src/main/java/com/mahjong/client/GameRoomController.java
new file mode 100644
--- /dev/null	(date 1717884182087)
+++ b/src/main/java/com/mahjong/client/GameRoomController.java	(date 1717884182087)
@@ -0,0 +1,818 @@
+package com.mahjong.client;
+
+import com.mmahjong.server.Server;
+import javafx.animation.KeyFrame;
+import javafx.animation.Timeline;
+import javafx.application.Platform;
+import javafx.event.ActionEvent;
+import javafx.fxml.FXML;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.control.Button;
+import javafx.scene.control.Label;
+import javafx.scene.image.Image;
+import javafx.scene.image.ImageView;
+import javafx.scene.input.MouseEvent;
+import javafx.scene.layout.*;
+import javafx.scene.media.Media;
+import javafx.scene.media.MediaPlayer;
+import javafx.scene.paint.Color;
+import javafx.scene.paint.ImagePattern;
+import javafx.scene.shape.Rectangle;
+import javafx.stage.Stage;
+import javafx.util.Duration;
+
+import logic.players.Player;
+import logic.rules.VictoryCheckRule;
+import logic.tiles.Tile;
+import logic.tilesSets.PlayedTileSet;
+
+import java.io.*;
+import java.net.Socket;
+import java.util.*;
+
+import java.util.logging.Logger;
+
+public class GameRoomController {
+    private static final Logger logger = Logger.getLogger(Server.class.getName());
+
+    @FXML
+    public Label autoHideLabel;
+
+    @FXML
+    public HBox player1LockedTiles;
+    @FXML
+    public VBox player2LockedTiles;
+    @FXML
+    public HBox player3LockedTiles;
+    @FXML
+    public VBox player4LockedTiles;
+
+    @FXML
+    public ArrayList<Label> playerLabelList;
+    @FXML
+    public ArrayList<Label> dealerLabelList;
+    @FXML
+    public ArrayList<Label> turnLabelList;
+    @FXML
+    public Label playerLabel1;
+    @FXML
+    public Label dealerLabel1;
+    @FXML
+    public Label turnLabel1;
+    @FXML
+    public Label playerLabel2;
+    @FXML
+    public Label dealerLabel2;
+    @FXML
+    public Label turnLabel2;
+    @FXML
+    public Label playerLabel3;
+    @FXML
+    public Label dealerLabel3;
+    @FXML
+    public Label turnLabel3;
+    @FXML
+    public Label playerLabel4;
+    @FXML
+    public Label dealerLabel4;
+    @FXML
+    public Label turnLabel4;
+    @FXML
+    public BorderPane rootPane;
+    public Button Hint;
+    public BorderPane gameBoard;
+
+    @FXML
+    private HBox player1Tiles;
+    @FXML
+    public VBox player2HandTiles;
+    @FXML
+    public HBox player3HandTiles;
+    @FXML
+    public VBox player4HandTiles;
+
+    @FXML
+    private VBox chowOptionsVBox;
+
+    @FXML
+    public TilePane rightTilePane;
+    @FXML
+    public TilePane leftTilePane;
+    @FXML
+    public TilePane topTilePane;
+    @FXML
+    private TilePane bottomTilePane;
+
+    private Socket socket;
+    private Rectangle selectedTile;
+    private ArrayList<Tile> handTileList;
+    private ArrayList<VBox> otherHandTileBoxList;
+
+    private ArrayList<TilePane> playedPane;
+    private ArrayList<PlayedTileSet> playedTileSetList;
+
+    private ArrayList<ArrayList<Tile>> lockedTileSetList;
+    private ArrayList<HBox> lockedBox1;
+    private ArrayList<VBox> lockedBox2;
+
+    private MediaPlayer mediaPlayer;
+    private List<String> musicList = new ArrayList<>();
+    private int currentSongIndex = 0;
+
+    private ObjectInputStream input;
+    private ObjectOutputStream output;
+    private boolean gameOver = false;
+    private ArrayList<Player> endPlayerList;
+    private String name;
+
+    // Image cache for preloading images
+    private Map<String, Image> imageCache = new HashMap<>();
+    @FXML
+    public void initialize() {
+        // Initialize lists for hand tiles, played tiles, locked tiles, and other players' hand tiles
+        handTileList = new ArrayList<>();
+        playedTileSetList = new ArrayList<>();
+        lockedTileSetList = new ArrayList<>();
+        otherHandTileBoxList = new ArrayList<>();
+
+        otherHandTileBoxList.add(player2HandTiles);
+        otherHandTileBoxList.add(player4HandTiles);
+
+        playerLabelList = new ArrayList<>();
+        dealerLabelList = new ArrayList<>();
+        turnLabelList = new ArrayList<>();
+        chowOptionsVBox.setVisible(false);
+
+        lockedBox1 = new ArrayList<>();
+        lockedBox2 = new ArrayList<>();
+        lockedBox1.add(player1LockedTiles);
+        lockedBox1.add(player3LockedTiles);
+        lockedBox2.add(player2LockedTiles);
+        lockedBox2.add(player4LockedTiles);
+
+        playerLabelList.add(playerLabel1);
+        playerLabelList.add(playerLabel2);
+        playerLabelList.add(playerLabel3);
+        playerLabelList.add(playerLabel4);
+
+        dealerLabelList.add(dealerLabel1);
+        dealerLabelList.add(dealerLabel2);
+        dealerLabelList.add(dealerLabel3);
+        dealerLabelList.add(dealerLabel4);
+
+        turnLabelList.add(turnLabel1);
+        turnLabelList.add(turnLabel2);
+        turnLabelList.add(turnLabel3);
+        turnLabelList.add(turnLabel4);
+
+        playedPane = new ArrayList<>();
+        playedPane.add(bottomTilePane);
+        playedPane.add(rightTilePane);
+        playedPane.add(topTilePane);
+        playedPane.add(leftTilePane);
+
+        name = "";
+
+        // Preload all possible images into the cache
+        preloadImages();
+        setBackground();
+//        loadMusic();
+    }
+    private void setBackground(){
+        Image backgroundImage = new Image(getClass().getResource("/images/backGround.png").toExternalForm());
+        BackgroundImage background = new BackgroundImage(backgroundImage,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
+                new BackgroundSize(100, 100, true, true, false, true)); // 调整BackgroundSize的参数以覆盖整个VBox
+        rootPane.setBackground(new Background(background));
+    }
+
+    // Preload all possible images into the cache
+    private void preloadImages() {
+        String[] tileTypes = {
+                "1Bamboo", "2Bamboo", "3Bamboo", "4Bamboo", "5Bamboo", "6Bamboo", "7Bamboo", "8Bamboo", "9Bamboo",
+                "1Character", "2Character", "3Character", "4Character", "5Character", "6Character", "7Character", "8Character", "9Character",
+                "1Dot", "2Dot", "3Dot", "4Dot", "5Dot", "6Dot", "7Dot", "8Dot", "9Dot",
+                "East", "South", "West", "North", "Red", "Green", "White", "tileBack"
+        };
+        for (String tileType : tileTypes) {
+            String imagePath = "/tiles/" + tileType + ".png";
+            Image image = new Image(getClass().getResource(imagePath).toExternalForm());
+            imageCache.put(tileType, image);
+        }
+    }
+
+    // Use cached images to set tile views
+    private Rectangle setTileImageView(Rectangle tile1, Tile tile, int width, int height, int direction) {
+        tile1.setWidth(width);
+        tile1.setHeight(height);
+        tile1.setArcWidth(10);
+        tile1.setArcHeight(10);
+
+        String tileType = tile.toString();
+        Image tileImage = imageCache.get(tileType);
+        if (tileImage == null) {
+            tileImage = new Image(getClass().getResource("/tiles/" + tileType + ".png").toExternalForm());
+            imageCache.put(tileType, tileImage);
+        }
+
+        ImageView tileImageView = new ImageView(tileImage);
+        tileImageView.setFitWidth(width);
+        tileImageView.setFitHeight(height);
+        if (direction == 1) {
+            tileImageView.setRotate(270);
+        } else if (direction == 2) {
+            tileImageView.setRotate(180);
+        } else if (direction == 3) {
+            tileImageView.setRotate(90);
+        }
+        tile1.setFill(new ImagePattern(tileImageView.snapshot(null, null)));
+        return tile1;
+    }
+
+    // Handle tile click events
+    @FXML
+    public void handleTileClick(MouseEvent event) {
+        if (selectedTile == event.getSource() && selectedTile.getStroke() == Color.YELLOW) {
+            selectedTile.setStroke(null);
+        } else {
+            if (selectedTile != null) {
+                selectedTile.setStroke(null); // Remove highlight from previously selected tile
+            }
+
+            selectedTile = (Rectangle) event.getSource();
+            selectedTile.setStroke(Color.YELLOW); // Highlight the selected tile
+            selectedTile.setStrokeWidth(3);
+        }
+    }
+
+    // Handle the discard action
+    @FXML
+    public void handleDiscard() throws IOException {
+        // Send message to server to update played tile; then receive message to update the board
+        if (selectedTile != null && selectedTile.getStroke() == Color.YELLOW && !Objects.equals(selectedTile.getId(), "")) {
+            sendOperation("Discard " + selectedTile.getId());
+            selectedTile.setStroke(null); // Remove highlight
+            selectedTile = null; // Reset selected tile
+        }
+    }
+
+    // Handle the get action
+    @FXML
+    public void handleGet(ActionEvent event) throws IOException {
+        sendOperation("Get");
+    }
+
+    // Handle the chow action
+    @FXML
+    public void handleChow(ActionEvent event) throws IOException {
+        sendOperation("Chow");
+    }
+
+    // Handle the skip action
+    @FXML
+    public void handleSkip(ActionEvent event) throws IOException {
+        sendOperation("Skip");
+    }
+
+    // Handle the pong action
+    @FXML
+    public void handlePong(ActionEvent event) throws IOException {
+        sendOperation("Pong");
+    }
+
+    // Handle the kong action
+    @FXML
+    public void handleKong(ActionEvent event) throws IOException {
+        sendOperation("Kong");
+    }
+
+    // Handle the Hu (win) action
+    @FXML
+    public void handleHu(ActionEvent event) throws IOException {
+        sendOperation("Hu");
+    }
+
+    // Send operation to the server
+    private void sendOperation(String operation) throws IOException {
+        output.reset();
+        output.writeObject(operation);
+        output.flush();
+    }
+
+    // Set network connection
+    public void setNetwork(Socket socket, ObjectInputStream input, ObjectOutputStream output) throws IOException {
+        name = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        this.socket = socket;
+        this.input = input;
+        this.output = output;
+        // Receive players and tile sets from the server
+        new Thread(() -> {
+            try {
+                while (true) {
+                    try {
+                        logger.info("Client ready to read data");
+                        Object message = input.readObject();
+
+                        if (message instanceof String) {
+                            String msg = (String) message;
+                            String[] parts = msg.split(" ");
+
+                            if (Objects.equals(parts[0], "chowTypes")) {
+                                Platform.runLater(() -> showChowChoice(msg));
+                            } else if (Objects.equals(parts[0], "Hu")) {
+                                Platform.runLater(() -> {
+                                    try {
+                                        gameOver(msg, endPlayerList);
+                                    } catch (IOException e) {
+                                        throw new RuntimeException(e);
+                                    }
+                                });
+                            } else if (Objects.equals(parts[0], "GameOver")) {
+                                gameOver = true;
+                            } else if (Objects.equals(parts[0], "Disconnect")) {
+                                socket.close();
+                            } else {
+                                Platform.runLater(() -> showMsg(msg));
+                            }
+                        } else {
+                            ArrayList<Player> playerList = (ArrayList<Player>) message;
+                            if (gameOver) {
+                                endPlayerList = new ArrayList<>(playerList);
+                            }
+                            for (Player player : playerList) {
+                                logger.info("" + player.getHandTileSet().getTileSets());
+                            }
+                            Platform.runLater(() -> updateGameBoard(playerList));
+                        }
+
+                    } catch (Exception e) {
+                        e.printStackTrace();
+                        System.out.println(socket.getRemoteSocketAddress() + " server disconnected");
+                        input.close();
+                        output.close();
+                        socket.close();
+                        break;
+                    }
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }).start();
+    }
+
+    // End the game and handle the end game logic
+    private void gameOver(String msg, ArrayList<Player> endPlayerList) throws IOException {
+        String[] parts = msg.split(" ");
+        String victoryPlayerName = parts[1];
+        ArrayList<ArrayList<Tile>> victoryTiles = null;
+        for (Player player : endPlayerList) {
+            if (Objects.equals(player.getName(), victoryPlayerName)) {
+                victoryTiles = VictoryCheckRule.joinHandLockedTile(player.getHandTileSet().getTileSets(), player.getLockedTileSet().getTileSets());
+            }
+        }
+
+        int index = 0;
+        String[] names = {"East", "South", "West", "North"};
+        for (Player player : endPlayerList) {
+            if (Objects.equals(player.getName(), parts[1])) {
+                index = endPlayerList.indexOf(player);
+            }
+        }
+
+        parts[1] = names[index];
+
+        String newMsg = String.join(" ", parts);
+
+        FXMLLoader loader = new FXMLLoader(getClass().getResource("overRoom.fxml"));
+        Scene overScene = new Scene(loader.load(), 1000, 1000);
+
+        // Get the current window
+        Stage stage = (Stage) autoHideLabel.getScene().getWindow();
+        stage.setScene(overScene);
+
+        OverRoomController controller = loader.getController();
+        controller.initialize(newMsg, victoryTiles, endPlayerList, this.name);
+
+        sendOperation("Disconnect");
+        // Close the socket
+        input.close();
+        output.close();
+        socket.close();
+    }
+
+    // Show chow choice options
+    private void showChowChoice(String msg) {
+        chowOptionsVBox.getChildren().clear(); // Clear previous options
+
+        String[] parts = msg.split(" ");
+        if (parts.length <= 2) {
+            chowOptionsVBox.setVisible(false);
+            return;
+        }
+
+        String tile = parts[1];
+        char firstChar = tile.charAt(0);
+        int magnitude = Character.getNumericValue(firstChar);
+
+        for (int i = 2; i < parts.length; i++) {
+            ArrayList<String> chowTiles = new ArrayList<>();
+            String tile1 = "";
+            String tile2 = "";
+            if (Objects.equals(parts[i], "1")) {
+                tile1 = (magnitude - 2) + tile.substring(1);
+                tile2 = (magnitude - 1) + tile.substring(1);
+            } else if (Objects.equals(parts[i], "2")) {
+                tile1 = (magnitude - 1) + tile.substring(1);
+                tile2 = (magnitude + 1) + tile.substring(1);
+            } else if (Objects.equals(parts[i], "3")) {
+                tile1 = (magnitude + 1) + tile.substring(1);
+                tile2 = (magnitude + 2) + tile.substring(1);
+            }
+
+            chowTiles.add(tile1);
+            chowTiles.add(tile2);
+
+            VBox optionBox = new VBox();
+            optionBox.setSpacing(10);
+
+            HBox tilesBox = new HBox();
+            tilesBox.setSpacing(5);
+
+            for (String tiles : chowTiles) {
+                Rectangle tileRect = new Rectangle(30, 45);
+                tileRect.setArcWidth(10);
+                tileRect.setArcHeight(10);
+                Image tileImage = imageCache.get(tiles);
+                if (tileImage == null) {
+                    tileImage = new Image(getClass().getResource("/tiles/" + tiles + ".png").toExternalForm());
+                    imageCache.put(tiles, tileImage);
+                }
+                tileRect.setFill(new ImagePattern(tileImage));
+                tilesBox.getChildren().add(tileRect);
+            }
+
+            Button selectButton = new Button("Select");
+            int finalI = i;
+            selectButton.setOnAction(e -> {
+                try {
+                    sendOperation("Chow " + parts[finalI]);
+                    chowOptionsVBox.setVisible(false); // Hide options after selection
+                } catch (IOException ioException) {
+                    ioException.printStackTrace();
+                }
+            });
+
+            optionBox.getChildren().addAll(tilesBox, selectButton);
+            chowOptionsVBox.getChildren().add(optionBox);
+        }
+
+        chowOptionsVBox.setVisible(true);
+    }
+
+    // Show a message on the screen
+    private void showMsg(String msg) {
+        autoHideLabel.setText(msg);
+        autoHideLabel.setVisible(true);
+
+        Timeline timeline = new Timeline(new KeyFrame(
+                Duration.seconds(4),
+                event -> autoHideLabel.setVisible(false)
+        ));
+        timeline.setCycleCount(1);
+        timeline.play();
+    }
+
+    // Update the game board
+    private void updateGameBoard(ArrayList<Player> playerList) {
+        updatePlayerName(playerList);
+        updateDealerState(playerList);
+        updateTurnState(playerList);
+        updateOthersHandTileDisplay(playerList);
+        updatePlayer1HandTileDisplay(playerList);
+        updatePlayedTileDisplay(playerList);
+        updateLockedTile(playerList);
+    }
+
+    // Find the index of the player in the player list
+    private int findIndexOfPlayer(String name, ArrayList<Player> playerList) {
+        for (Player player : playerList) {
+            if (Objects.equals(player.getName(), socket.getLocalAddress().toString() + ":" + socket.getLocalPort())) {
+                return playerList.indexOf(player);
+            }
+        }
+        return -1;
+    }
+
+    // Update player names
+    private void updatePlayerName(ArrayList<Player> playerList) {
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+
+        String[] names = {"East", "South", "West", "North"};
+
+        int i = 0;
+        while (i != 4) {
+            playerLabelList.get(i).setText(names[index]);
+            i++;
+            index = (index + 1) % playerList.size();
+        }
+    }
+
+    // Update dealer state
+    private void updateDealerState(ArrayList<Player> playerList) {
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+
+        int i = 0;
+        while (i != 4) {
+            if (playerList.get(index).getDealerState()) {
+                dealerLabelList.get(i).setText("Dealer");
+            }
+            i++;
+            index = (index + 1) % playerList.size();
+        }
+    }
+
+    // Update turn state
+    private void updateTurnState(ArrayList<Player> playerList) {
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+
+        int i = 0;
+        while (i != 4) {
+            if (playerList.get(index).getTurnState()) {
+                turnLabelList.get(i).setText("Acting");
+            } else {
+                turnLabelList.get(i).setText("Waiting");
+            }
+            i++;
+            index = (index + 1) % playerList.size();
+        }
+    }
+
+    // Update other players' hand tiles display
+    private void updateOthersHandTileDisplay(ArrayList<Player> playerList) {
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+        // Horizontal
+        int m = (index + 1) % playerList.size();
+        m = (m + 1) % playerList.size();
+
+        int handTileNumbers = playerList.get(m).getHandTileSet().getTileNumber();
+        player3HandTiles.getChildren().clear();
+        for (int j = 0; j < handTileNumbers; j++) {
+            Rectangle tile1 = new Rectangle();
+            tile1 = setHideTileImage(tile1, 30, 45, 2);
+            player3HandTiles.getChildren().add(tile1);
+        }
+
+        // Vertical
+        int i = 0;
+        m = (index + 1) % playerList.size();
+        while (i != 2) {
+            handTileNumbers = playerList.get(m).getHandTileSet().getTileNumber();
+            otherHandTileBoxList.get(i).getChildren().clear();
+            for (int j = 0; j < handTileNumbers; j++) {
+                Rectangle tile1 = new Rectangle();
+                if (i == 0) {
+                    tile1 = setHideTileImage(tile1, 45, 30, 1);
+                    otherHandTileBoxList.get(i).getChildren().add(tile1);
+                } else {
+                    tile1 = setHideTileImage(tile1, 45, 30, 3);
+                    otherHandTileBoxList.get(i).getChildren().add(tile1);
+                }
+            }
+            i++;
+            m = (m + 1) % playerList.size();
+            m = (m + 1) % playerList.size();
+        }
+    }
+
+    // Set hidden tile image
+    private Rectangle setHideTileImage(Rectangle tile1, int width, int height, int direction) {
+        tile1.setWidth(width);
+        tile1.setHeight(height);
+        tile1.setArcWidth(10);
+        tile1.setArcHeight(10);
+        Image tileImage = imageCache.get("tileBack");
+        if (tileImage == null) {
+            tileImage = new Image(getClass().getResource("/tiles/tileBack.png").toExternalForm());
+            imageCache.put("tileBack", tileImage);
+        }
+        ImageView tileImageView = new ImageView(tileImage);
+        tileImageView.setFitWidth(width);
+        tileImageView.setFitHeight(height);
+        tileImageView.setPreserveRatio(true); // Maintain aspect ratio
+        tileImageView.setSmooth(true); // Smooth processing
+        if (direction == 1) {
+            tileImageView.setRotate(270);
+        } else if (direction == 2) {
+            tileImageView.setRotate(180);
+        } else if (direction == 3) {
+            tileImageView.setRotate(90);
+        }
+        tile1.setFill(new ImagePattern(tileImageView.snapshot(null, null)));
+        return tile1;
+    }
+
+    // Update player's hand tiles display
+    private void updatePlayer1HandTileDisplay(ArrayList<Player> playerList) {
+        // Update hand tiles
+        handTileList.clear();
+        for (Player player : playerList) {
+            if (Objects.equals(player.getName(), socket.getLocalAddress().toString() + ":" + socket.getLocalPort())) {
+                for (ArrayList<Tile> tileList : player.getHandTileSet().getTileSets()) {
+                    for (Tile tile : tileList) {
+                        handTileList.add(tile);
+                    }
+                }
+            }
+        }
+
+        player1Tiles.getChildren().clear();
+        for (Tile tile : handTileList) {
+            Rectangle tile1 = new Rectangle();
+            tile1.setId(tile.toString());
+            tile1.setWidth(30);
+            tile1.setHeight(45);
+            tile1.setArcWidth(10);
+            tile1.setArcHeight(10);
+            tile1.setOnMouseClicked((MouseEvent event) -> {
+                handleTileClick(event);
+            });
+            String tileType = tile.toString();
+            Image tileImage = imageCache.get(tileType);
+            if (tileImage == null) {
+                tileImage = new Image(getClass().getResource("/tiles/" + tileType + ".png").toExternalForm());
+                imageCache.put(tileType, tileImage);
+            }
+            tile1.setFill(new ImagePattern(tileImage));
+            player1Tiles.getChildren().add(tile1);
+        }
+    }
+
+    // Update played tiles display
+    private void updatePlayedTileDisplay(ArrayList<Player> playerList) {
+        // Get played tiles
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+
+        playedTileSetList.clear();
+        for (Player player : playerList) {
+            playedTileSetList.add(player.getPlayedTileSet());
+        }
+        // Update played tiles
+        int i = 0;
+        while (i != 4) {
+            playedPane.get(i).getChildren().clear();
+            for (Tile tile : playedTileSetList.get(index).getTileSets()) {
+                Rectangle tile1 = new Rectangle();
+                if (i == 0 || i == 2) {
+                    tile1 = setTileImageView(tile1, tile, 30, 45, i);
+                } else if (i == 1 || i == 3) {
+                    tile1 = setTileImageView(tile1, tile, 45, 30, i);
+                }
+                playedPane.get(i).getChildren().add(tile1);
+            }
+            i++;
+            index = (index + 1) % playerList.size();
+        }
+    }
+
+    // Update locked tiles display
+    private void updateLockedTile(ArrayList<Player> playerList) {
+        String playerName = socket.getLocalAddress().toString() + ":" + socket.getLocalPort();
+        int index = findIndexOfPlayer(playerName, playerList);
+
+        lockedTileSetList.clear();
+
+        for (Player player : playerList) {
+            ArrayList<Tile> lockedTileSet = new ArrayList<>();
+            for (ArrayList<Tile> tileSet : player.getLockedTileSet().getTileSets()) {
+                lockedTileSet.addAll(tileSet);
+            }
+            lockedTileSetList.add(lockedTileSet);
+        }
+
+        setPlayerLockedTileDisplay(index, playerList);
+    }
+
+    // Set player's locked tile display
+    private void setPlayerLockedTileDisplay(int index, ArrayList<Player> playerList) {
+        // Horizontal
+        int i = 0;
+        int m = index;
+        while (i != 2) {
+            lockedBox1.get(i).getChildren().clear();
+            for (Tile tile : lockedTileSetList.get(m)) {
+                Rectangle tile1 = new Rectangle();
+                if (i == 0) {
+                    tile1 = setTileImageView(tile1, tile, 30, 45, 0);
+                } else {
+                    tile1 = setTileImageView(tile1, tile, 30, 45, 2);
+                }
+                lockedBox1.get(i).getChildren().add(tile1);
+            }
+            i++;
+            m = (m + 1) % playerList.size();
+            m = (m + 1) % playerList.size();
+        }
+        // Vertical
+        i = 0;
+        m = (index + 1) % playerList.size();
+        while (i != 2) {
+            lockedBox2.get(i).getChildren().clear();
+            for (Tile tile : lockedTileSetList.get(m)) {
+                Rectangle tile1 = new Rectangle();
+                if (i == 0) {
+                    tile1 = setTileImageView(tile1, tile, 45, 30, 1);
+                } else {
+                    tile1 = setTileImageView(tile1, tile, 45, 30, 3);
+                }
+                lockedBox2.get(i).getChildren().add(tile1);
+            }
+            i++;
+            m = (m + 1) % playerList.size();
+            m = (m + 1) % playerList.size();
+        }
+    }
+
+    // Handle music play/pause
+    @FXML
+    private void handleMusic(ActionEvent event) {
+        if (mediaPlayer == null) {
+            if (!musicList.isEmpty()) {
+                playSong(currentSongIndex);
+            }
+        } else {
+            MediaPlayer.Status status = mediaPlayer.getStatus();
+            if (status == MediaPlayer.Status.PLAYING) {
+                mediaPlayer.pause();
+            } else {
+                mediaPlayer.play();
+            }
+        }
+    }
+
+    // Handle playing the next song
+    @FXML
+    private void handleNext(ActionEvent event) {
+        playNextSong();
+    }
+
+    // Handle playing the previous song
+    @FXML
+    private void handlePrevious(ActionEvent event) {
+        playPreviousSong();
+    }
+
+    // Load music from predefined folder
+    private void loadMusic() {
+        File musicFolder = new File(getClass().getResource("/music/").getPath());
+        if (musicFolder.isDirectory()) {
+            for (File file : musicFolder.listFiles()) {
+                if (file.isFile() && (file.getName().endsWith(".mp3"))) {
+                    musicList.add(file.toURI().toString());
+                }
+            }
+        }
+        if (!musicList.isEmpty()) {
+            playSong(currentSongIndex);
+        }
+    }
+
+    // Play a song by index
+    private void playSong(int index) {
+        if (mediaPlayer != null) {
+            mediaPlayer.stop();
+        }
+        Media media = new Media(musicList.get(index));
+        mediaPlayer = new MediaPlayer(media);
+        mediaPlayer.setOnEndOfMedia(this::playNextSong);
+        mediaPlayer.play();
+    }
+
+    // Play the next song in the list
+    private void playNextSong() {
+        currentSongIndex = (currentSongIndex + 1) % musicList.size();
+        playSong(currentSongIndex);
+    }
+
+    // Play the previous song in the list
+    private void playPreviousSong() {
+        currentSongIndex = (currentSongIndex - 1 + musicList.size()) % musicList.size();
+        playSong(currentSongIndex);
+    }
+
+    // Show hint messages
+    public void handleHint(ActionEvent event) {
+        showMsg("1. One player discards a tile, game come into check state.\n" +
+                "other players need to skip or Pong/Kong! to finish check state!\n" +
+                "2. You can Chow (if you can) or Get when it's your turn!\n" +
+                "3. If you want to discard, you need to finish your necessary operate!\n" +
+                "4. After get/chow/pong, you need to discard a tile" +
+                "5. After kong, you need to get a tile first then discard!\n" +
+                "6. All illegal operations will be rejected!");
+    }
+}
Index: src/main/java/com/mahjong/client/OverRoomController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mahjong/client/OverRoomController.java b/src/main/java/com/mahjong/client/OverRoomController.java
new file mode 100644
--- /dev/null	(date 1717879159375)
+++ b/src/main/java/com/mahjong/client/OverRoomController.java	(date 1717879159375)
@@ -0,0 +1,105 @@
+package com.mahjong.client;
+
+import javafx.event.ActionEvent;
+import javafx.fxml.FXML;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Scene;
+import javafx.scene.control.Label;
+import javafx.scene.image.Image;
+import javafx.scene.layout.*;
+import javafx.scene.paint.ImagePattern;
+import javafx.scene.shape.Rectangle;
+import javafx.stage.Stage;
+import logic.players.Player;
+import logic.tiles.Tile;
+
+import java.io.IOException;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Objects;
+
+public class OverRoomController {
+    public VBox vBox;
+    @FXML
+    private Label scoringLabel;
+    @FXML
+    private HBox showVictoryTiles;
+    @FXML
+    private Label playerNameLabel;
+    @FXML
+    private Label victoryTypeLabel;
+    @FXML
+    private Label playerHandLabel;
+
+    // Initialize the controller with the victory message, victory tiles, player list, and player's name
+    @FXML
+    public void initialize(String msg, ArrayList<ArrayList<Tile>> victoryTiles, ArrayList<Player> players, String name) {
+        showVictoryMsg(msg, players, name);
+        showVictoryTiles(victoryTiles);
+
+        Image backgroundImage = new Image(getClass().getResource("/images/backGround.png").toExternalForm());
+        BackgroundImage background = new BackgroundImage(backgroundImage,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
+                new BackgroundSize(100, 100, true, true, false, true)); // 调整BackgroundSize的参数以覆盖整个VBox
+        vBox.setBackground(new Background(background));
+    }
+
+    // Display the victory tiles
+    private void showVictoryTiles(ArrayList<ArrayList<Tile>> victoryTiles) {
+        ArrayList<Tile> handTileList = new ArrayList<>();
+        for (ArrayList<Tile> tileList : victoryTiles) {
+            handTileList.addAll(tileList);
+        }
+
+        showVictoryTiles.getChildren().clear();
+        for (Tile tile : handTileList) {
+            Rectangle tile1 = new Rectangle(30, 45);
+            tile1.setArcWidth(10);
+            tile1.setArcHeight(10);
+            String tileType = tile.toString();
+            Image tileImage = new Image(getClass().getResource("/tiles/" + tileType + ".png").toExternalForm());
+            tile1.setFill(new ImagePattern(tileImage));
+            showVictoryTiles.getChildren().add(tile1);
+        }
+    }
+
+    // Display the victory message
+    private void showVictoryMsg(String msg, ArrayList<Player> players, String name) {
+        for (Player player : players) {
+            if (Objects.equals(name, player.getName())) {
+                scoringLabel.setText("Your Scoring: " + player.getScoring());
+            }
+        }
+
+        String[] victoryTypes = {
+                "All Triplets", "Big Single Wait", "Zhuo Wu Kui", "Hai Di Lao Yue", "Yi Tiao Long",
+                "Qi Dui Zi", "Gang Shang Kai Hua", "Qing Yi Se", "Super Qi Dui Zi", "Pi Hu"
+        };
+        String[] parts = msg.split(" ");
+        StringBuilder victoryMsgBuilder = new StringBuilder();
+        playerNameLabel.setText(parts[1]);
+
+        for (int i = 2; i < parts.length; i++) {
+            int index = Integer.parseInt(parts[i]);
+            victoryMsgBuilder.append(victoryTypes[index]).append("    ");
+        }
+
+        victoryTypeLabel.setText(victoryMsgBuilder.toString());
+        playerHandLabel.setText("Victory Player's HandTiles!!!");
+    }
+
+    // Continue the game and return to the menu
+    public void continueGame(ActionEvent event) throws IOException {
+        FXMLLoader loader = new FXMLLoader(getClass().getResource("menu.fxml"));
+        Scene gameRoomWaitScene = new Scene(loader.load(), 1000, 1000);
+
+        Stage stage = (Stage) playerNameLabel.getScene().getWindow();
+        stage.setScene(gameRoomWaitScene);
+    }
+
+    // Exit the game
+    public void exitGame(ActionEvent event) {
+        Stage stage = (Stage) playerNameLabel.getScene().getWindow();
+        stage.close();
+    }
+}
Index: src/main/java/com/mahjong/client/MenuController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/mahjong/client/MenuController.java b/src/main/java/com/mahjong/client/MenuController.java
new file mode 100644
--- /dev/null	(date 1717878570676)
+++ b/src/main/java/com/mahjong/client/MenuController.java	(date 1717878570676)
@@ -0,0 +1,73 @@
+package com.mahjong.client;
+
+import javafx.event.ActionEvent;
+import javafx.fxml.FXML;
+import javafx.fxml.FXMLLoader;
+import javafx.scene.Node;
+import javafx.scene.Scene;
+import javafx.scene.control.Button;
+import javafx.scene.image.Image;
+import javafx.scene.layout.*;
+import javafx.stage.Stage;
+
+import java.io.IOException;
+
+public class MenuController {
+    @FXML
+    private VBox vbox;
+    @FXML
+    private Button gameStartButton;
+    @FXML
+    private Button gameRulesButton;
+    @FXML
+    private Button exitGameButton;
+
+    // Handle the event of starting the game
+    @FXML
+    public void initialize() {
+        // 设置背景图片
+        Image backgroundImage = new Image(getClass().getResource("/images/backGround.png").toExternalForm());
+        BackgroundImage background = new BackgroundImage(backgroundImage,
+                BackgroundRepeat.NO_REPEAT, BackgroundRepeat.NO_REPEAT, BackgroundPosition.CENTER,
+                new BackgroundSize(100, 100, true, true, false, true)); // 调整BackgroundSize的参数以覆盖整个VBox
+        vbox.setBackground(new Background(background));
+    }
+
+
+    @FXML
+    private void handleGameStart() throws IOException {
+        // Load the game waiting room interface
+        FXMLLoader loader = new FXMLLoader(getClass().getResource("gameRoomWait.fxml"));
+        Scene waitingScene = new Scene(loader.load(), 1000, 1000);
+
+        // Get the current window
+        Stage stage = (Stage) gameStartButton.getScene().getWindow();
+        stage.setScene(waitingScene);
+
+        // Initialize network communication
+        WaitRoomController controller = loader.getController();
+        controller.initializeNet(stage);
+    }
+
+    // Handle the event of showing game rules
+    @FXML
+    private void handleGameRules() throws IOException {
+        // TODO: Display game rules
+        // Load the game rules interface
+        FXMLLoader loader = new FXMLLoader(getClass().getResource("gameRule.fxml"));
+        Scene gameRuleScene = new Scene(loader.load(), 1000, 1000);
+
+        // Get the current window
+        Stage stage = (Stage) gameRulesButton.getScene().getWindow();
+        stage.setScene(gameRuleScene);
+    }
+
+    // Handle the event of exiting the game
+    @FXML
+    private void handleExitGame() {
+        // Close the application
+        Stage stage = (Stage) exitGameButton.getScene().getWindow();
+        stage.close();
+    }
+}
+
Index: src/main/java/com/example/mahjong/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/example/mahjong/Client.java b/src/main/java/com/mahjong/client/Client.java
rename from src/main/java/com/example/mahjong/Client.java
rename to src/main/java/com/mahjong/client/Client.java
--- a/src/main/java/com/example/mahjong/Client.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/com/mahjong/client/Client.java	(date 1717871674247)
@@ -1,4 +1,4 @@
-package com.example.mahjong;
+package com.mahjong.client;
 
 import javafx.application.Application;
 import javafx.fxml.FXMLLoader;
@@ -6,19 +6,21 @@
 import javafx.stage.Stage;
 
 import java.io.IOException;
+import java.net.Socket;
 
 public class Client extends Application {
-
     @Override
     public void start(Stage stage) throws IOException {
-        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("login.fxml"));
-        Scene scene = new Scene(fxmlLoader.load(), 600, 400);
+        // Load the FXML file for the main menu and set up the scene
+        FXMLLoader fxmlLoader = new FXMLLoader(Client.class.getResource("menu.fxml"));
+        Scene scene = new Scene(fxmlLoader.load(), 1000, 1000);
         stage.setTitle("Mahjong");
         stage.setScene(scene);
         stage.show();
     }
 
     public static void main(String[] args) {
+        // Launch the JavaFX application
         launch();
     }
-}
\ No newline at end of file
+}
Index: src/main/java/module-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module com.example.mahjong {\r\n    requires javafx.controls;\r\n    requires javafx.fxml;\r\n    requires javafx.web;\r\n\r\n    requires org.controlsfx.controls;\r\n    requires com.dlsc.formsfx;\r\n    requires net.synedra.validatorfx;\r\n    requires org.kordamp.ikonli.javafx;\r\n    requires org.kordamp.bootstrapfx.core;\r\n    requires eu.hansolo.tilesfx;\r\n    requires com.almasb.fxgl.all;\r\n\r\n    opens com.example.mahjong to javafx.fxml;\r\n    exports com.example.mahjong;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/module-info.java b/src/main/java/module-info.java
--- a/src/main/java/module-info.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/module-info.java	(date 1717880252984)
@@ -10,7 +10,9 @@
     requires org.kordamp.bootstrapfx.core;
     requires eu.hansolo.tilesfx;
     requires com.almasb.fxgl.all;
+    requires java.logging;
+    requires org.testng;
 
-    opens com.example.mahjong to javafx.fxml;
-    exports com.example.mahjong;
+    opens com.mahjong.client to javafx.fxml;
+    exports com.mahjong.client;
 }
\ No newline at end of file
Index: src/main/java/logic/rules/PlayerOperateCheckRule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/rules/PlayerOperateCheckRule.java b/src/main/java/logic/rules/PlayerOperateCheckRule.java
new file mode 100644
--- /dev/null	(date 1717876365158)
+++ b/src/main/java/logic/rules/PlayerOperateCheckRule.java	(date 1717876365158)
@@ -0,0 +1,326 @@
+package logic.rules;
+
+import logic.games.Game;
+import logic.players.Player;
+import logic.tiles.Tile;
+import logic.tilesSets.HandTileSet;
+import logic.tilesSets.LockedTileSet;
+
+import java.util.ArrayList;
+import java.util.Objects;
+
+import static com.mmahjong.server.Server.logger;
+
+public class PlayerOperateCheckRule {
+    private static PlayerOperateCheckRule uniqueInstance = null;
+
+    // Singleton pattern to ensure only one instance of PlayerOperateCheckRule exists
+    public static PlayerOperateCheckRule getInstance() {
+        if (uniqueInstance == null) {
+            uniqueInstance = new PlayerOperateCheckRule();
+        }
+        return uniqueInstance;
+    }
+
+    // Private constructor for Singleton pattern
+    private PlayerOperateCheckRule() {
+    }
+
+    // Check if the player's operation is legal
+    public static boolean checkOperateLegal(String remoteSocketAddress, String operate, Game game) {
+        logger.info("------Check Player Operation Legality------" + remoteSocketAddress + "------" + operate);
+        ArrayList<Player> playerList = game.getPlayerList();
+        String[] parts = operate.split(" ");
+        Player operatePlayer = null;
+
+        for (Player player : playerList) {
+            // Find the player
+            if (Objects.equals(player.getName(), remoteSocketAddress)) {
+                operatePlayer = player;
+            }
+        }
+        logger.info("------Found the Player------" + remoteSocketAddress);
+        if (operatePlayer == null) {
+            System.out.println("Player does not exist");
+            return false;
+        }
+
+        if (game.getCheckState()) {
+            logger.info("------Game--Pong/Kong Check Phase--Operation Legality Check------");
+            if (operatePlayer.getTurnState()) {
+                logger.info("------Game--Pong/Kong Check Phase--Player is the discarder, illegal operation------");
+                return false;
+            } else {
+                if (Objects.equals(parts[0], "Pong")) {
+                    logger.info("------Game--Pong/Kong Check Phase--Pong Operation Check------");
+                    return checkCanPong(operatePlayer, game.getEndPlayerDiscardTile());
+
+                } else if (Objects.equals(parts[0], "Kong")) {
+                    logger.info("------Game--Pong/Kong Check Phase--Bright Kong Operation Check------");
+                    return checkCanBrightKong(operatePlayer, game.getEndPlayerDiscardTile());
+
+                } else if (Objects.equals(parts[0], "Hu")) {
+                    logger.info("------Game--Pong/Kong Check Phase--Hu Operation Check------");
+                    return checkCanHu(operatePlayer, game, game.getEndPlayerDiscardTile());
+
+                } else if (Objects.equals(parts[0], "Skip")) {
+                    logger.info("------Game--Pong/Kong Check Phase--Skip Operation Check------");
+                    return true;
+                }
+            }
+        } else {
+            logger.info("------Game--Player Operation Phase--Operation Legality Check------");
+            if (operatePlayer.getTurnState()) {
+                logger.info("------Game--Player Operation Phase--Player Turn Operation------");
+                if (Objects.equals(parts[0], "Discard")) {
+                    logger.info("------Game--Player Operation Phase--Discard Operation Check------");
+                    return checkCanDiscard(operatePlayer);
+
+                } else if (Objects.equals(parts[0], "Get")) {
+                    logger.info("------Game--Player Operation Phase--Get Operation Check------");
+                    return checkCanGet(operatePlayer);
+
+                } else if (Objects.equals(parts[0], "Chow") && !Objects.equals(operate, "Chow")) {
+                    logger.info("------Game--Player Operation Phase--Discard Operation Check------");
+                    return checkCanChow(operatePlayer, game.getEndPlayerDiscardTile()) && operatePlayer.getCanChow();
+
+                } else if (Objects.equals(operate, "Chow")) {
+                    if (game.getEndPlayerDiscardTile() != null) {
+                        logger.info("------Game--Player Operation Phase--Chow Operation Check------");
+                        return checkCanChow(operatePlayer, game.getEndPlayerDiscardTile()) && operatePlayer.getCanChow();
+                    }
+                    return false;
+
+                } else if (Objects.equals(parts[0], "Kong")) {
+                    logger.info("------Game--Player Operation Phase--Pong Operation Check------");
+                    return checkCanKong(operatePlayer);
+
+                } else if (Objects.equals(parts[0], "Hu")) {
+                    logger.info("------Game--Player Operation Phase--Hu Operation Check------" + checkCanHu(operatePlayer, game));
+                    return checkCanHu(operatePlayer, game);
+                }
+            }
+            logger.info("------Game--Player Operation Phase--Illegal Operation Outside Player Turn------");
+        }
+        return false;
+    }
+
+    // Check if the player can perform Pong
+    public static boolean checkCanPong(Player operatePlayer, Tile endPlayerDiscardTile) {
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileSet.getTileSets());
+        if (endPlayerDiscardTile != null) {
+            int count = 0;
+            for (ArrayList<Tile> tileSet : copyHandTileArrayList) {
+                count = 0;
+                for (Tile tile : tileSet) {
+                    if (Objects.equals(tile.getType(), endPlayerDiscardTile.getType()) && tile.getMagnitude() == endPlayerDiscardTile.getMagnitude()) {
+                        count++;
+                        if (count == 2) {
+                            return true;
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+        return false;
+    }
+
+    // Check if the player can perform Bright Kong
+    public static boolean checkCanBrightKong(Player operatePlayer, Tile endPlayerDiscardTile) {
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileSet.getTileSets());
+        if (endPlayerDiscardTile != null) {
+            int count = 0;
+            for (ArrayList<Tile> tileSet : copyHandTileArrayList) {
+                count = 0;
+                for (Tile tile : tileSet) {
+                    if (Objects.equals(tile.getType(), endPlayerDiscardTile.getType()) && tile.getMagnitude() == endPlayerDiscardTile.getMagnitude()) {
+                        count++;
+                        if (count == 3) {
+                            return true;
+                        }
+                    }
+                }
+            }
+            return false;
+        }
+        return false;
+    }
+
+    // Check if the player can perform Dark Kong or Kong after self-draw
+    public static boolean checkCanKong(Player operatePlayer) {
+        Rule rule = Rule.getInstance();
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        LockedTileSet lockedTileSet = operatePlayer.getLockedTileSet();
+
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileSet.getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTileArrayList = VictoryCheckRule.deepCopyTileSet(lockedTileSet.getTileSets());
+
+        ArrayList<Tile> kongSet = new ArrayList<>();
+        for (ArrayList<Tile> tileSet : copyHandTileArrayList) {
+            kongSet.addAll(rule.checkKong(tileSet));
+        }
+
+        System.out.println(kongSet);
+        return kongSet.size() == 4;
+    }
+
+    // Check if the player can Hu (self-draw)
+    public static boolean checkCanHu(Player operatePlayer, Game game) {
+
+        VictoryCheckRule victoryCheckRule = VictoryCheckRule.getInstance();
+        String victoryMsg = "";
+
+        victoryMsg = checkAllVictoryConditions(game, operatePlayer, victoryCheckRule, victoryMsg);
+
+        if (victoryMsg != null) {
+            game.setSelfMo(true);
+        }
+        return !victoryMsg.isEmpty();
+    }
+
+    // Check if the player can Hu (after discard)
+    public static boolean checkCanHu(Player operatePlayer, Game game, Tile endPlayerDiscardTile) {
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        VictoryCheckRule victoryCheckRule = VictoryCheckRule.getInstance();
+        String victoryMsg = "";
+        handTileSet.addTile(endPlayerDiscardTile);
+        handTileSet.sort();
+
+        victoryMsg = checkAllVictoryConditions(game, operatePlayer, victoryCheckRule, victoryMsg);
+
+        if (victoryMsg.isEmpty()) {
+            handTileSet.discardTile(endPlayerDiscardTile.toString());
+        }
+
+        return !victoryMsg.isEmpty();
+    }
+
+    // Check all victory conditions for a player
+    public static String checkAllVictoryConditions(Game game, Player player, VictoryCheckRule victoryCheckRule, String victoryMsg) {
+        if (victoryCheckRule.allTriplets(player)) {
+            victoryMsg += "0 ";
+        }
+        if (victoryCheckRule.bigSingleWait(player)) {
+            victoryMsg += "1 ";
+        }
+        if (victoryCheckRule.zhuoWuKui(player)) {
+            victoryMsg += "2 ";
+        }
+        if (victoryCheckRule.haiDiLaoYue(player, game.getLibraryTileSet(), game.getKongNumber())) {
+            victoryMsg += "3 ";
+        }
+        if (victoryCheckRule.yiTiaoLong(player)) {
+            victoryMsg += "4 ";
+        }
+        if (victoryCheckRule.qiDuiZi(player)) {
+            victoryMsg += "5 ";
+        }
+        if (victoryCheckRule.gangShangKaiHua(player)) {
+            victoryMsg += "6 ";
+        }
+        if (victoryCheckRule.qingYiSe(player)) {
+            victoryMsg += "7 ";
+        }
+        if (victoryCheckRule.superQiDuiZi(player)) {
+            victoryMsg += "8 ";
+        }
+        if (victoryCheckRule.basicHu(player)) {
+            victoryMsg += "9 ";
+        }
+        System.out.println(victoryMsg);
+        return victoryMsg;
+    }
+
+    // Check if the player can discard
+    private static boolean checkCanDiscard(Player operatePlayer) {
+        return operatePlayer.getCanDiscard();
+    }
+
+    // Check if the player can draw a tile
+    private static boolean checkCanGet(Player operatePlayer) {
+        return operatePlayer.getCanGet();
+    }
+
+    // Check if the player can Chow
+    public static boolean checkCanChow(Player operatePlayer, Tile endPlayerDiscardTile) {
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileSet.getTileSets());
+
+        if (Objects.equals(endPlayerDiscardTile.getType(), "Character")) {
+            return checkCanChowByType("Character", copyHandTileArrayList, endPlayerDiscardTile);
+
+        } else if (Objects.equals(endPlayerDiscardTile.getType(), "Bamboo")) {
+            return checkCanChowByType("Bamboo", copyHandTileArrayList, endPlayerDiscardTile);
+
+        } else if (Objects.equals(endPlayerDiscardTile.getType(), "Dot")) {
+            return checkCanChowByType("Dot", copyHandTileArrayList, endPlayerDiscardTile);
+
+        } else {
+            return false;
+        }
+    }
+
+    // Check if the player can Chow based on tile type
+    private static boolean checkCanChowByType(String type, ArrayList<ArrayList<Tile>> copyHandTileArrayList, Tile endPlayerDiscardTile) {
+        int index = -1;
+        if (Objects.equals(type, "Character")) index = 0;
+        if (Objects.equals(type, "Bamboo")) index = 1;
+        if (Objects.equals(type, "Dot")) index = 2;
+
+        if (endPlayerDiscardTile.getMagnitude() == 1) {
+            return tileInList(copyHandTileArrayList.get(index), 2, 3);
+
+        } else if (endPlayerDiscardTile.getMagnitude() == 2) {
+            return tileInList(copyHandTileArrayList.get(index), 1, 3) || tileInList(copyHandTileArrayList.get(index), 3, 4);
+
+        } else if (endPlayerDiscardTile.getMagnitude() == 8) {
+            return tileInList(copyHandTileArrayList.get(index), 6, 7) || tileInList(copyHandTileArrayList.get(index), 7, 9);
+
+        } else if (endPlayerDiscardTile.getMagnitude() == 9) {
+            return tileInList(copyHandTileArrayList.get(index), 7, 8);
+
+        } else {
+            int magnitude = endPlayerDiscardTile.getMagnitude();
+            return tileInList(copyHandTileArrayList.get(index), magnitude - 1, magnitude - 2) || tileInList(copyHandTileArrayList.get(index), magnitude - 1, magnitude + 1) || tileInList(copyHandTileArrayList.get(index), magnitude + 1, magnitude + 2);
+        }
+    }
+
+    // Get types of Chow possible for the player
+    public static String getCanChowTypes(Player operatePlayer, Tile endPlayerDiscardTile) {
+        HandTileSet handTileSet = operatePlayer.getHandTileSet();
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileSet.getTileSets());
+        int index = -1;
+        if (Objects.equals(endPlayerDiscardTile.getType(), "Character")) index = 0;
+        if (Objects.equals(endPlayerDiscardTile.getType(), "Bamboo")) index = 1;
+        if (Objects.equals(endPlayerDiscardTile.getType(), "Dot")) index = 2;
+
+        String types = "chowTypes " + endPlayerDiscardTile.toString() + " ";
+        if (tileInList(copyHandTileArrayList.get(index), endPlayerDiscardTile.getMagnitude() - 1, endPlayerDiscardTile.getMagnitude() - 2)) {
+            types = types + "1 ";
+        }
+        if (tileInList(copyHandTileArrayList.get(index), endPlayerDiscardTile.getMagnitude() - 1, endPlayerDiscardTile.getMagnitude() + 1)) {
+            types = types + "2 ";
+        }
+        if (tileInList(copyHandTileArrayList.get(index), endPlayerDiscardTile.getMagnitude() + 1, endPlayerDiscardTile.getMagnitude() + 2)) {
+            types = types + "3 ";
+        }
+        return types;
+    }
+
+    // Check if specific tiles are in the list
+    private static boolean tileInList(ArrayList<Tile> tileArrayList, int i, int j) {
+        boolean checkI = false;
+        boolean checkJ = false;
+        for (Tile tile : tileArrayList) {
+            if (tile.getMagnitude() == i) {
+                checkI = true;
+            } else if (tile.getMagnitude() == j) {
+                checkJ = true;
+            }
+        }
+        return checkI && checkJ;
+    }
+}
Index: src/main/java/logic/factories/test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/test.java b/src/main/java/logic/factories/test.java
new file mode 100644
--- /dev/null	(date 1717847502504)
+++ b/src/main/java/logic/factories/test.java	(date 1717847502504)
@@ -0,0 +1,32 @@
+package logic.factories;
+
+import logic.tiles.Tile;
+import logic.tilesSets.TileSet;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+
+public class test {
+    public static void main(String[] args){
+        TilesSetsFactory singleTilesSetsProducer = TilesSetsFactoryProducer.getTilesSetFactory(true);
+        TilesSetsFactory doubleTilesSetsProducer = TilesSetsFactoryProducer.getTilesSetFactory(false);
+        TileSet libraryTileSet = singleTilesSetsProducer.getTileSet("Library");
+        TileSet playedTileSet = singleTilesSetsProducer.getTileSet("Played");
+        TileSet handTileSet = doubleTilesSetsProducer.getTileSet("HandTile");
+        libraryTileSet.sort();
+        for (Object tile:libraryTileSet.getTileSets()){
+
+            System.out.println(tile);
+        }
+        for (int i = 0; i < 13; i++){
+            handTileSet.addTile(libraryTileSet.discardTile(""));
+        }
+        ArrayList<ArrayList<Tile>> arrayLists = handTileSet.getTileSets();
+        for (ArrayList<Tile> arrayList: arrayLists){
+            arrayList.sort(null);
+        }
+        System.out.println(playedTileSet.getTileSets());
+        System.out.println(libraryTileSet.getTileNumber());
+        System.out.println(handTileSet.getTileSets());
+    }
+}
Index: src/main/java/logic/rules/VictoryCheckRule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/rules/VictoryCheckRule.java b/src/main/java/logic/rules/VictoryCheckRule.java
new file mode 100644
--- /dev/null	(date 1717876171740)
+++ b/src/main/java/logic/rules/VictoryCheckRule.java	(date 1717876171740)
@@ -0,0 +1,274 @@
+package logic.rules;
+
+import logic.players.Player;
+import logic.tiles.Tile;
+import logic.tilesSets.LibraryTileSet;
+
+import java.util.ArrayList;
+import java.util.Objects;
+
+public class VictoryCheckRule {
+
+    private static VictoryCheckRule uniqueInstance = null;
+    private Rule rule;
+
+    // Singleton pattern to ensure only one instance of VictoryCheckRule exists
+    public static VictoryCheckRule getInstance() {
+        if (uniqueInstance == null) {
+            uniqueInstance = new VictoryCheckRule();
+        }
+        return uniqueInstance;
+    }
+
+    // Private constructor for Singleton pattern
+    private VictoryCheckRule() {
+        rule = Rule.getInstance();
+    }
+
+    // Return a sorted final hand copy including locked tiles
+    public static ArrayList<ArrayList<Tile>> joinHandLockedTile(ArrayList<ArrayList<Tile>> handTileArrayList, ArrayList<ArrayList<Tile>> lockedTileArrayList) {
+        if (handTileArrayList == null || lockedTileArrayList == null) {
+            throw new IllegalArgumentException("Input arrays cannot be null");
+        }
+
+        ArrayList<ArrayList<Tile>> copyHandTileArrayList = VictoryCheckRule.deepCopyTileSet(handTileArrayList);
+
+        for (ArrayList<Tile> tileArrayList : lockedTileArrayList) {
+            for (Tile tile : tileArrayList) {
+                if (tile == null) continue;
+                switch (tile.getType()) {
+                    case "Character":
+                        copyHandTileArrayList.get(0).add(tile);
+                        break;
+                    case "Bamboo":
+                        copyHandTileArrayList.get(1).add(tile);
+                        break;
+                    case "Dot":
+                        copyHandTileArrayList.get(2).add(tile);
+                        break;
+                    default:
+                        copyHandTileArrayList.get(3).add(tile);
+                        break;
+                }
+            }
+        }
+
+        for (ArrayList<Tile> tileArrayList : copyHandTileArrayList) {
+            tileArrayList.sort(null);
+        }
+
+        return copyHandTileArrayList;
+    }
+
+    // Return a deep copy of a nested list
+    public static ArrayList<ArrayList<Tile>> deepCopyTileSet(ArrayList<ArrayList<Tile>> original) {
+        if (original == null) {
+            return null;
+        }
+
+        ArrayList<ArrayList<Tile>> copy = new ArrayList<>();
+
+        for (ArrayList<Tile> tileSet : original) {
+            if (tileSet == null) {
+                copy.add(null);
+                continue;
+            }
+
+            ArrayList<Tile> newTileSet = new ArrayList<>();
+            for (Tile tile : tileSet) {
+                if (tile != null) {
+                    newTileSet.add(tile);
+                }
+            }
+            newTileSet.sort(null);
+            copy.add(newTileSet);
+        }
+
+        return copy;
+    }
+
+    // Check if the player has four triplets and one pair
+    public boolean allTriplets(Player operatePlayer) {
+        boolean allTriplets = false;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+
+        if (rule.getTripletNumber(checkedTileSet) == 4) {
+            allTriplets = true;
+        }
+        return basicHu(operatePlayer) && allTriplets;
+    }
+
+    // Check if the player has a big single wait
+    public boolean bigSingleWait(Player operatePlayer) {
+        boolean bigSingleWaitCheck = false;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        if (copyLockedTile.get(0).size() / 3 + copyLockedTile.get(1).size() / 3 == 4) {
+            if (rule.getPairNumber(copyHandTile) == 1) {
+                bigSingleWaitCheck = true;
+            }
+        }
+        return basicHu(operatePlayer) && bigSingleWaitCheck;
+    }
+
+    // Check if the player wins with Zhuo Wu Kui
+    public boolean zhuoWuKui(Player operatePlayer) {
+        boolean zhuoWuKuiCheck = Objects.equals(operatePlayer.getHandTileSet().getEndGetTile().toString(), "5Character");
+        return (basicHu(operatePlayer) && zhuoWuKuiCheck) || (qiDuiZi(operatePlayer) && zhuoWuKuiCheck) || (superQiDuiZi(operatePlayer) && zhuoWuKuiCheck);
+    }
+
+    // Check if the player wins with Hai Di Lao Yue
+    public boolean haiDiLaoYue(Player operatePlayer, LibraryTileSet libraryTileSet, int kongNumber) {
+        boolean haiDiLaoYueCheck = false;
+        if (libraryTileSet.getTileNumber() == (4 * kongNumber)) {
+            haiDiLaoYueCheck = true;
+        }
+        return (basicHu(operatePlayer) && haiDiLaoYueCheck) || (qiDuiZi(operatePlayer) && haiDiLaoYueCheck) || (superQiDuiZi(operatePlayer) && haiDiLaoYueCheck);
+    }
+
+    // Check if the player wins with Yi Tiao Long
+    public boolean yiTiaoLong(Player operatePlayer) {
+        boolean yiTiaoLongCheck = false;
+
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+
+        for (ArrayList<Tile> tileSet : checkedTileSet) {
+            int j = 1;
+            for (Tile tile : tileSet) {
+                if (tile.getMagnitude() == j) {
+                    j++;
+                }
+            }
+            if (j == 10) {
+                yiTiaoLongCheck = true;
+            }
+        }
+        return basicHu(operatePlayer) && yiTiaoLongCheck;
+    }
+
+    // Check if the player wins with Qi Dui Zi
+    public boolean qiDuiZi(Player operatePlayer) {
+        boolean victory = false;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+        if (rule.getPairNumber(checkedTileSet) == 7 && rule.getKongNumber(checkedTileSet) == 0 && rule.getTripletNumber(checkedTileSet) == 0) {
+            victory = true;
+        }
+        return victory;
+    }
+
+    // Check if the player wins with Gang Shang Kai Hua
+    public boolean gangShangKaiHua(Player operatePlayer) {
+        boolean gangShangKaiHuaCheck = false;
+
+        Tile endKongTile = operatePlayer.getHandTileSet().getEndKongTile();
+        if (endKongTile != null) {
+            if (Objects.equals(operatePlayer.getHandTileSet().getEndSecondGetTile().toString(), endKongTile.toString())) {
+                gangShangKaiHuaCheck = true;
+            }
+        }
+        return (basicHu(operatePlayer) && gangShangKaiHuaCheck) || (qiDuiZi(operatePlayer) && gangShangKaiHuaCheck) || (superQiDuiZi(operatePlayer) && gangShangKaiHuaCheck);
+    }
+
+    // Check if the player wins with Qing Yi Se
+    public boolean qingYiSe(Player operatePlayer) {
+        boolean qingYiSeCheck = false;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+
+        if (!checkedTileSet.get(0).isEmpty() && checkedTileSet.get(1).isEmpty() && checkedTileSet.get(2).isEmpty() && checkedTileSet.get(3).isEmpty()) {
+            qingYiSeCheck = true;
+        }
+        if (checkedTileSet.get(0).isEmpty() && !checkedTileSet.get(1).isEmpty() && checkedTileSet.get(2).isEmpty() && checkedTileSet.get(3).isEmpty()) {
+            qingYiSeCheck = true;
+        }
+        if (checkedTileSet.get(0).isEmpty() && checkedTileSet.get(1).isEmpty() && !checkedTileSet.get(2).isEmpty() && checkedTileSet.get(3).isEmpty()) {
+            qingYiSeCheck = true;
+        }
+
+        return (basicHu(operatePlayer) && qingYiSeCheck) || (qiDuiZi(operatePlayer) && qingYiSeCheck) || (qiDuiZi(operatePlayer) && qingYiSeCheck);
+    }
+
+    // Check if the player wins with Super Qi Dui Zi
+    public boolean superQiDuiZi(Player operatePlayer) {
+        boolean victory = false;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+        if (rule.getPairNumber(checkedTileSet) == 7 && rule.getKongNumber(checkedTileSet) == 1 && rule.getTripletNumber(copyHandTile) == 0) {
+            victory = true;
+        }
+        return victory;
+    }
+
+    // Basic Hu check (3*4+2 structure)
+    public boolean basicHu(Player operatePlayer) {
+        return kongFirstCheck(operatePlayer) || kongLastCheck(operatePlayer);
+    }
+
+    private boolean kongFirstCheck(Player operatePlayer) {
+        return checkPlayerTiles(operatePlayer, true, true) || checkPlayerTiles(operatePlayer, true, false);
+    }
+
+    private boolean kongLastCheck(Player operatePlayer) {
+        return checkPlayerTiles(operatePlayer, false, true) || checkPlayerTiles(operatePlayer, false, false);
+    }
+
+    private boolean checkPlayerTiles(Player operatePlayer, boolean isKongFirst, boolean isSequenceFirst) {
+        boolean victory = false;
+        int pair = 1;
+        int nonPair = 4;
+        ArrayList<ArrayList<Tile>> copyHandTile = deepCopyTileSet(operatePlayer.getHandTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> copyLockedTile = deepCopyTileSet(operatePlayer.getLockedTileSet().getTileSets());
+        ArrayList<ArrayList<Tile>> checkedTileSet = joinHandLockedTile(copyHandTile, copyLockedTile);
+
+        if (isKongFirst) {
+            nonPair -= rule.getKongNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkKong(tileSet));
+            }
+        }
+
+        if (isSequenceFirst) {
+            nonPair -= rule.getSequenceNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkSequence(tileSet));
+            }
+
+            nonPair -= rule.getTripletNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkTriplet(tileSet));
+            }
+        } else {
+            nonPair -= rule.getTripletNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkTriplet(tileSet));
+            }
+
+            nonPair -= rule.getSequenceNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkSequence(tileSet));
+            }
+        }
+
+        if (!isKongFirst) {
+            nonPair -= rule.getKongNumber(checkedTileSet);
+            for (ArrayList<Tile> tileSet : checkedTileSet) {
+                tileSet.removeAll(rule.checkKong(tileSet));
+            }
+        }
+
+        pair -= rule.getPairNumber(checkedTileSet);
+
+        if (pair == 0 && nonPair == 0) {
+            victory = true;
+        }
+        return victory;
+    }
+}
Index: src/main/java/logic/rules/ScoringRule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.rules;\r\n\r\npublic class ScoringRule {\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/rules/ScoringRule.java b/src/main/java/logic/rules/ScoringRule.java
--- a/src/main/java/logic/rules/ScoringRule.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/rules/ScoringRule.java	(date 1717875650777)
@@ -1,4 +1,86 @@
 package logic.rules;
 
+import logic.games.Game;
+import logic.players.Player;
+
+import java.util.ArrayList;
+import java.util.Objects;
+
 public class ScoringRule {
+    private static ScoringRule uniqueInstance = null;
+
+    // Singleton pattern to ensure only one instance of ScoringRule exists
+    public static ScoringRule getInstance() {
+        if (uniqueInstance == null) {
+            uniqueInstance = new ScoringRule();
+        }
+        return uniqueInstance;
+    }
+
+    // Private constructor for Singleton pattern
+    private ScoringRule() {
+    }
+
+    // Calculate the scoring based on victory types, the game state, and the list of players
+    public void getScoring(String victoryTypes, Game game, ArrayList<Player> playerArrayList) {
+        String[] parts = victoryTypes.split(" ");
+        int[] scoringList = new int[]{1, 1, 1, 1};
+        int indexOfVictoryPlayer = 0;
+
+        // Find the index of the victory player
+        for (Player player : playerArrayList) {
+            if (Objects.equals(player.getName(), game.getVictoryPlayer().getName())) {
+                indexOfVictoryPlayer = playerArrayList.indexOf(player);
+            }
+        }
+
+        int indexOfLastPlayer = playerArrayList.indexOf(game.getLastPlayer());
+
+        // Calculate the scoring based on the victory types
+        for (String s : parts) {
+            switch (s) {
+                case "0":
+                case "1":
+                case "2":
+                case "3":
+                    scoringList[indexOfVictoryPlayer] *= 2;
+                    break;
+                case "4":
+                    scoringList[indexOfVictoryPlayer] *= 3;
+                    break;
+                case "5":
+                    scoringList[indexOfVictoryPlayer] *= 4;
+                    break;
+                case "6":
+                    scoringList[indexOfVictoryPlayer] *= 5;
+                    break;
+                case "7":
+                    scoringList[indexOfVictoryPlayer] *= 6;
+                    break;
+                case "8":
+                    scoringList[indexOfVictoryPlayer] *= 8;
+                    break;
+            }
+        }
+
+        // Apply additional scoring rules
+        if (game.getSelfMo()) { // Self-draw condition
+            scoringList[indexOfVictoryPlayer] *= 3;
+            for (Player player : playerArrayList) {
+                if (!Objects.equals(player.getName(), game.getVictoryPlayer().getName())) {
+                    int index = playerArrayList.indexOf(player);
+                    scoringList[index] *= -1;
+                }
+            }
+        } else { // Normal win condition
+            scoringList[indexOfLastPlayer] *= -1;
+        }
+
+        // Update the scoring for each player
+        int i = 0;
+        for (int s : scoringList) {
+            playerArrayList.get(i).setScoring(s);
+            i++;
+        }
+    }
 }
Index: src/main/java/logic/rules/Rule.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.rules;\r\n\r\nimport logic.tiles.Tile;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class Rule {\r\n\r\n    public ArrayList<Tile> checkSequence(ArrayList<Tile> tileSet){\r\n        ArrayList<Tile> sequenceSet = new ArrayList<>();\r\n        ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);\r\n        if (checkingTileSet.size() >= 3){\r\n            int i = 0;\r\n            boolean sequence;\r\n            while (i < checkingTileSet.size()){\r\n                sequence = false;\r\n                for (int j = 1; j < checkingTileSet.size() && !sequence; j++){\r\n                    if (checkingTileSet.get(i).getMagnitude() == checkingTileSet.get(j).getMagnitude() - 1) {\r\n                        for (int k = j + 1; k < checkingTileSet.size() && !sequence; k++) {\r\n                            if (checkingTileSet.get(j).getMagnitude() == checkingTileSet.get(k).getMagnitude() - 1) {\r\n                                sequenceSet.add(checkingTileSet.get(i));\r\n                                sequenceSet.add(checkingTileSet.get(j));\r\n                                sequenceSet.add(checkingTileSet.get(k));\r\n                                checkingTileSet.remove(k);\r\n                                checkingTileSet.remove(j);\r\n                                checkingTileSet.remove(i);\r\n                                sequence = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!sequence){\r\n                    checkingTileSet.remove(0);\r\n                }\r\n            }\r\n        }\r\n        return sequenceSet;\r\n    }\r\n\r\n    public int getSequenceNumber(ArrayList<ArrayList<Tile>> handTileSet){\r\n        ArrayList<Tile> sequenceSet = new ArrayList<>();\r\n        for (ArrayList<Tile> tileSet : handTileSet){\r\n            sequenceSet.addAll(checkSequence(tileSet));\r\n        }\r\n        return sequenceSet.size() / 3;\r\n    }\r\n\r\n\r\n\r\n    public ArrayList<Tile> checkTriplet(ArrayList<Tile> tileSet){\r\n        ArrayList<Tile> tripletSet = new ArrayList<>();\r\n        ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);\r\n        if (checkingTileSet.size() >= 3){\r\n            int i = 0;\r\n            boolean triplet;\r\n            boolean kong;\r\n            while (i < checkingTileSet.size()){\r\n                triplet = false;\r\n                kong = false;\r\n                if (i + 2 < checkingTileSet.size()){\r\n                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){\r\n                        if (checkingTileSet.get(i+2).getMagnitude() == checkingTileSet.get(i).getMagnitude()) {\r\n                            if (i+3 < checkingTileSet.size()){\r\n                                if (checkingTileSet.get(i+3).getMagnitude() != checkingTileSet.get(i).getMagnitude()){\r\n                                    tripletSet.add(checkingTileSet.get(i));\r\n                                    tripletSet.add(checkingTileSet.get(i+1));\r\n                                    tripletSet.add(checkingTileSet.get(i+2));\r\n                                    checkingTileSet.remove(i+2);\r\n                                    checkingTileSet.remove(i+1);\r\n                                    checkingTileSet.remove(i);\r\n                                    triplet = true;\r\n                                }else {\r\n                                    kong = true;\r\n                                }\r\n                            }else {\r\n                                tripletSet.add(checkingTileSet.get(i));\r\n                                tripletSet.add(checkingTileSet.get(i+1));\r\n                                tripletSet.add(checkingTileSet.get(i+2));\r\n                                checkingTileSet.remove(i+2);\r\n                                checkingTileSet.remove(i+1);\r\n                                checkingTileSet.remove(i);\r\n                                triplet = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!triplet && !kong){\r\n                    checkingTileSet.remove(0);\r\n                }\r\n                if (kong){\r\n                    for (int n = 3; n > -1; n--){\r\n                        checkingTileSet.remove(n);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return tripletSet;\r\n    }\r\n\r\n    public int getTripletNumber(ArrayList<ArrayList<Tile>> handTileSet){\r\n        ArrayList<Tile> tripletSet = new ArrayList<>();\r\n        for (ArrayList<Tile> tileSet : handTileSet){\r\n            tripletSet.addAll(checkTriplet(tileSet));\r\n        }\r\n        return tripletSet.size() / 3;\r\n    }\r\n\r\n\r\n\r\n\r\n    public ArrayList<Tile> checkPair(ArrayList<Tile> tileSet){\r\n        ArrayList<Tile> pairSet = new ArrayList<>();\r\n        ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);\r\n        if (checkingTileSet.size() >= 2){\r\n            int i = 0;\r\n            boolean pair;\r\n            while (i < checkingTileSet.size()){\r\n                pair = false;\r\n                if (i + 1 < checkingTileSet.size()){\r\n                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){\r\n                        pairSet.add(checkingTileSet.get(i));\r\n                        pairSet.add(checkingTileSet.get(i+1));\r\n                        checkingTileSet.remove(i+1);\r\n                        checkingTileSet.remove(i);\r\n                        pair = true;\r\n                    }\r\n                }\r\n                if (!pair){\r\n                    checkingTileSet.remove(0);\r\n                }\r\n            }\r\n        }\r\n        return pairSet;\r\n    }\r\n\r\n    public int getPairNumber(ArrayList<ArrayList<Tile>> handTileSet){\r\n        ArrayList<Tile> pairSet = new ArrayList<>();\r\n        for (ArrayList<Tile> tileSet : handTileSet){\r\n            pairSet.addAll(checkPair(tileSet));\r\n        }\r\n        return pairSet.size() / 2;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    public ArrayList<Tile> checkKong(ArrayList<Tile> tileSet){\r\n        ArrayList<Tile> kongSet = new ArrayList<>();\r\n        ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);\r\n        if (checkingTileSet.size() >= 3){\r\n            int i = 0;\r\n            boolean kong;\r\n            while (i < checkingTileSet.size()){\r\n                kong = false;\r\n                if (i + 3 < checkingTileSet.size()){\r\n                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){\r\n                        if (checkingTileSet.get(i+2).getMagnitude() == checkingTileSet.get(i).getMagnitude()) {\r\n                            if (checkingTileSet.get(i+3).getMagnitude() == checkingTileSet.get(i).getMagnitude()){\r\n                                kongSet.add(checkingTileSet.get(i));\r\n                                kongSet.add(checkingTileSet.get(i+1));\r\n                                kongSet.add(checkingTileSet.get(i+2));\r\n                                kongSet.add(checkingTileSet.get(i+3));\r\n                                checkingTileSet.remove(i+3);\r\n                                checkingTileSet.remove(i+2);\r\n                                checkingTileSet.remove(i+1);\r\n                                checkingTileSet.remove(i);\r\n                                kong = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!kong){\r\n                    checkingTileSet.remove(0);\r\n                }\r\n            }\r\n        }\r\n        return kongSet;\r\n    }\r\n\r\n    public int getKongNumber(ArrayList<ArrayList<Tile>> handTileSet){\r\n        ArrayList<Tile> kongSet = new ArrayList<>();\r\n        for (ArrayList<Tile> tileSet : handTileSet){\r\n            kongSet.addAll(checkKong(tileSet));\r\n        }\r\n        return kongSet.size() / 4;\r\n    }\r\n\r\n\r\n\r\n\r\n    public boolean checkBurningDealer(){\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/rules/Rule.java b/src/main/java/logic/rules/Rule.java
--- a/src/main/java/logic/rules/Rule.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/rules/Rule.java	(date 1717876550743)
@@ -3,18 +3,40 @@
 import logic.tiles.Tile;
 
 import java.util.ArrayList;
+import java.util.Objects;
 
 public class Rule {
 
-    public ArrayList<Tile> checkSequence(ArrayList<Tile> tileSet){
+    private static Rule uniqueInstance = null;
+
+    // Singleton pattern to ensure only one instance of Rule exists
+    public static Rule getInstance() {
+        if (uniqueInstance == null) {
+            uniqueInstance = new Rule();
+        }
+        return uniqueInstance;
+    }
+
+    // Private constructor for Singleton pattern
+    private Rule() {
+    }
+
+    // Return a new list of sequences (Shun Zi)
+    public ArrayList<Tile> checkSequence(ArrayList<Tile> tileSet) {
         ArrayList<Tile> sequenceSet = new ArrayList<>();
         ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);
-        if (checkingTileSet.size() >= 3){
+
+        // Check if size is greater than or equal to 3
+        if (checkingTileSet.size() >= 3) {
             int i = 0;
             boolean sequence;
-            while (i < checkingTileSet.size()){
+
+            // Iterate through all tiles
+            while (i < checkingTileSet.size()) {
                 sequence = false;
-                for (int j = 1; j < checkingTileSet.size() && !sequence; j++){
+
+                // Identify i, j, k positions, remove from the original hand copy, and add to the sequence set
+                for (int j = i + 1; j < checkingTileSet.size() && !sequence; j++) {
                     if (checkingTileSet.get(i).getMagnitude() == checkingTileSet.get(j).getMagnitude() - 1) {
                         for (int k = j + 1; k < checkingTileSet.size() && !sequence; k++) {
                             if (checkingTileSet.get(j).getMagnitude() == checkingTileSet.get(k).getMagnitude() - 1) {
@@ -29,7 +51,9 @@
                         }
                     }
                 }
-                if (!sequence){
+
+                // If no sequence is found, remove and check the next one
+                if (!sequence) {
                     checkingTileSet.remove(0);
                 }
             }
@@ -37,95 +61,94 @@
         return sequenceSet;
     }
 
-    public int getSequenceNumber(ArrayList<ArrayList<Tile>> handTileSet){
+    // Get the number of sequences (Shun Zi) in the list
+    public int getSequenceNumber(ArrayList<ArrayList<Tile>> handTileSet) {
         ArrayList<Tile> sequenceSet = new ArrayList<>();
-        for (ArrayList<Tile> tileSet : handTileSet){
+        for (ArrayList<Tile> tileSet : handTileSet) {
             sequenceSet.addAll(checkSequence(tileSet));
         }
         return sequenceSet.size() / 3;
     }
 
-
-
-    public ArrayList<Tile> checkTriplet(ArrayList<Tile> tileSet){
+    // Exclude Kongs (Gang), return a new list of Triplets (Peng)
+    public ArrayList<Tile> checkTriplet(ArrayList<Tile> tileSet) {
         ArrayList<Tile> tripletSet = new ArrayList<>();
         ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);
-        if (checkingTileSet.size() >= 3){
+        if (checkingTileSet.size() >= 3) {
             int i = 0;
             boolean triplet;
             boolean kong;
-            while (i < checkingTileSet.size()){
+            while (i < checkingTileSet.size()) {
                 triplet = false;
                 kong = false;
-                if (i + 2 < checkingTileSet.size()){
-                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){
-                        if (checkingTileSet.get(i+2).getMagnitude() == checkingTileSet.get(i).getMagnitude()) {
-                            if (i+3 < checkingTileSet.size()){
-                                if (checkingTileSet.get(i+3).getMagnitude() != checkingTileSet.get(i).getMagnitude()){
+                if (i + 2 < checkingTileSet.size()) {
+                    if (checkingTileSet.get(i + 1).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 1).getType(), checkingTileSet.get(i).getType())) {
+                        if (checkingTileSet.get(i + 2).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 2).getType(), checkingTileSet.get(i).getType())) {
+                            if (i + 3 < checkingTileSet.size()) {
+                                // Exclude Kongs (Gang)
+                                if (checkingTileSet.get(i + 3).getMagnitude() != checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 3).getType(), checkingTileSet.get(i).getType())) {
                                     tripletSet.add(checkingTileSet.get(i));
-                                    tripletSet.add(checkingTileSet.get(i+1));
-                                    tripletSet.add(checkingTileSet.get(i+2));
-                                    checkingTileSet.remove(i+2);
-                                    checkingTileSet.remove(i+1);
+                                    tripletSet.add(checkingTileSet.get(i + 1));
+                                    tripletSet.add(checkingTileSet.get(i + 2));
+                                    checkingTileSet.remove(i + 2);
+                                    checkingTileSet.remove(i + 1);
                                     checkingTileSet.remove(i);
                                     triplet = true;
-                                }else {
+                                } else {
                                     kong = true;
                                 }
-                            }else {
+                            } else {
                                 tripletSet.add(checkingTileSet.get(i));
-                                tripletSet.add(checkingTileSet.get(i+1));
-                                tripletSet.add(checkingTileSet.get(i+2));
-                                checkingTileSet.remove(i+2);
-                                checkingTileSet.remove(i+1);
+                                tripletSet.add(checkingTileSet.get(i + 1));
+                                tripletSet.add(checkingTileSet.get(i + 2));
+                                checkingTileSet.remove(i + 2);
+                                checkingTileSet.remove(i + 1);
                                 checkingTileSet.remove(i);
                                 triplet = true;
                             }
                         }
                     }
                 }
-                if (!triplet && !kong){
+
+                if (!triplet && !kong) {
                     checkingTileSet.remove(0);
                 }
-                if (kong){
-                    for (int n = 3; n > -1; n--){
-                        checkingTileSet.remove(n);
-                    }
+                if (kong) {
+                    checkingTileSet.subList(0, 4).clear();
                 }
             }
         }
         return tripletSet;
     }
 
-    public int getTripletNumber(ArrayList<ArrayList<Tile>> handTileSet){
+    // Get the number of Triplets (Peng) in the list, excluding Kongs (Gang)
+    public int getTripletNumber(ArrayList<ArrayList<Tile>> handTileSet) {
         ArrayList<Tile> tripletSet = new ArrayList<>();
-        for (ArrayList<Tile> tileSet : handTileSet){
+        for (ArrayList<Tile> tileSet : handTileSet) {
             tripletSet.addAll(checkTriplet(tileSet));
         }
         return tripletSet.size() / 3;
     }
 
-
-
-
-    public ArrayList<Tile> checkPair(ArrayList<Tile> tileSet){
+    // Return a new list of pairs, considering Peng and Gang
+    public ArrayList<Tile> checkPair(ArrayList<Tile> tileSet) {
         ArrayList<Tile> pairSet = new ArrayList<>();
         ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);
-        if (checkingTileSet.size() >= 2){
+        if (checkingTileSet.size() >= 2) {
             int i = 0;
             boolean pair;
-            while (i < checkingTileSet.size()){
+            while (i < checkingTileSet.size()) {
                 pair = false;
-                if (i + 1 < checkingTileSet.size()){
-                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){
+                if (i + 1 < checkingTileSet.size()) {
+                    if (checkingTileSet.get(i + 1).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 1).getType(), checkingTileSet.get(i).getType())) {
                         pairSet.add(checkingTileSet.get(i));
-                        pairSet.add(checkingTileSet.get(i+1));
-                        checkingTileSet.remove(i+1);
+                        pairSet.add(checkingTileSet.get(i + 1));
+                        checkingTileSet.remove(i + 1);
                         checkingTileSet.remove(i);
                         pair = true;
                     }
                 }
-                if (!pair){
+                if (!pair) {
                     checkingTileSet.remove(0);
                 }
             }
@@ -133,44 +156,42 @@
         return pairSet;
     }
 
-    public int getPairNumber(ArrayList<ArrayList<Tile>> handTileSet){
+    // Get the number of pairs in the list
+    public int getPairNumber(ArrayList<ArrayList<Tile>> handTileSet) {
         ArrayList<Tile> pairSet = new ArrayList<>();
-        for (ArrayList<Tile> tileSet : handTileSet){
+        for (ArrayList<Tile> tileSet : handTileSet) {
             pairSet.addAll(checkPair(tileSet));
         }
         return pairSet.size() / 2;
     }
 
-
-
-
-
-    public ArrayList<Tile> checkKong(ArrayList<Tile> tileSet){
+    // Return a new list of Kongs (Gang)
+    public ArrayList<Tile> checkKong(ArrayList<Tile> tileSet) {
         ArrayList<Tile> kongSet = new ArrayList<>();
         ArrayList<Tile> checkingTileSet = new ArrayList<>(tileSet);
-        if (checkingTileSet.size() >= 3){
+        if (checkingTileSet.size() >= 4) {
             int i = 0;
             boolean kong;
-            while (i < checkingTileSet.size()){
+            while (i < checkingTileSet.size()) {
                 kong = false;
-                if (i + 3 < checkingTileSet.size()){
-                    if (checkingTileSet.get(i+1).getMagnitude() == checkingTileSet.get(i).getMagnitude()){
-                        if (checkingTileSet.get(i+2).getMagnitude() == checkingTileSet.get(i).getMagnitude()) {
-                            if (checkingTileSet.get(i+3).getMagnitude() == checkingTileSet.get(i).getMagnitude()){
+                if (i + 3 < checkingTileSet.size()) {
+                    if (checkingTileSet.get(i + 1).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 1).getType(), checkingTileSet.get(i).getType())) {
+                        if (checkingTileSet.get(i + 2).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 2).getType(), checkingTileSet.get(i).getType())) {
+                            if (checkingTileSet.get(i + 3).getMagnitude() == checkingTileSet.get(i).getMagnitude() && Objects.equals(checkingTileSet.get(i + 3).getType(), checkingTileSet.get(i).getType())) {
                                 kongSet.add(checkingTileSet.get(i));
-                                kongSet.add(checkingTileSet.get(i+1));
-                                kongSet.add(checkingTileSet.get(i+2));
-                                kongSet.add(checkingTileSet.get(i+3));
-                                checkingTileSet.remove(i+3);
-                                checkingTileSet.remove(i+2);
-                                checkingTileSet.remove(i+1);
+                                kongSet.add(checkingTileSet.get(i + 1));
+                                kongSet.add(checkingTileSet.get(i + 2));
+                                kongSet.add(checkingTileSet.get(i + 3));
+                                checkingTileSet.remove(i + 3);
+                                checkingTileSet.remove(i + 2);
+                                checkingTileSet.remove(i + 1);
                                 checkingTileSet.remove(i);
                                 kong = true;
                             }
                         }
                     }
                 }
-                if (!kong){
+                if (!kong) {
                     checkingTileSet.remove(0);
                 }
             }
@@ -178,21 +199,12 @@
         return kongSet;
     }
 
-    public int getKongNumber(ArrayList<ArrayList<Tile>> handTileSet){
+    // Get the number of Kongs (Gang) in the list
+    public int getKongNumber(ArrayList<ArrayList<Tile>> handTileSet) {
         ArrayList<Tile> kongSet = new ArrayList<>();
-        for (ArrayList<Tile> tileSet : handTileSet){
+        for (ArrayList<Tile> tileSet : handTileSet) {
             kongSet.addAll(checkKong(tileSet));
         }
         return kongSet.size() / 4;
     }
-
-
-
-
-    public boolean checkBurningDealer(){
-
-        return true;
-    }
-
-
 }
Index: src/main/java/logic/games/Game.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/games/Game.java b/src/main/java/logic/games/Game.java
new file mode 100644
--- /dev/null	(date 1717876550747)
+++ b/src/main/java/logic/games/Game.java	(date 1717876550747)
@@ -0,0 +1,417 @@
+package logic.games;
+
+import com.mmahjong.server.Server;
+import logic.factories.TilesSetsFactory;
+import logic.factories.TilesSetsFactoryProducer;
+import logic.players.Player;
+import logic.rules.PlayerOperateCheckRule;
+import logic.rules.VictoryCheckRule;
+import logic.tiles.*;
+import logic.tilesSets.LibraryTileSet;
+
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.Objects;
+import java.util.Random;
+
+import static com.mmahjong.server.Server.logger;
+
+public class Game {
+    private ArrayList<Player> playerList;
+    private LibraryTileSet libraryTileSet;
+    private boolean checkState;
+    private boolean gameState;
+    private Tile endPlayerDiscardTile;
+    private Tile endPlayerGetTile;
+    private int indexOfDealer;
+    private int kongNumber;
+    private Player lastPlayer;
+    private Player victoryPlayer;
+    private boolean selfMo;
+
+    public Game() {
+        playerList = new ArrayList<>();
+
+        TilesSetsFactory singleArrayListFactory = TilesSetsFactoryProducer.getTilesSetFactory(true);
+        libraryTileSet = (LibraryTileSet) singleArrayListFactory.getTileSet("Library");
+
+        checkState = false;
+        gameState = true;
+        selfMo = false;
+
+        endPlayerDiscardTile = null;
+        endPlayerGetTile = null;
+        indexOfDealer = -1;
+        kongNumber = 0;
+        lastPlayer = null;
+        victoryPlayer = null;
+    }
+
+    // Initialize the game with a list of online sockets
+    public void gameInit(ArrayList<Socket> onLineSocket) {
+        for (Socket socket : onLineSocket) {
+            playerList.add(new Player(socket.getRemoteSocketAddress().toString()));
+        }
+
+        libraryTileSet.sort();
+
+        chooseDealer(playerList);
+        dealTiles(playerList);
+    }
+
+    // Choose a random dealer from the player list
+    private void chooseDealer(ArrayList<Player> playerList) {
+        Random random = new Random();
+        int index = random.nextInt(playerList.size());
+        indexOfDealer = index;
+        playerList.get(indexOfDealer).setDealerState(true);
+        playerList.get(indexOfDealer).setTurnState(true);
+
+        System.out.println(playerList.get(index).getCanDarkKong());
+    }
+
+    // Deal tiles to all players, with special tiles for the dealer
+    private void dealTiles(ArrayList<Player> playerList) {
+        Player dealerPlayer = playerList.get(indexOfDealer);
+        for (Player player : playerList) {
+            for (int i = 0; i < 13; i++) {
+                player.getHandTileSet().addTile(libraryTileSet.discardTile("Tile"));
+                player.getHandTileSet().sort();
+            }
+        }
+
+        // Special tiles for the dealer
+        for (ArrayList<Tile> arrayList : dealerPlayer.getHandTileSet().getTileSets()) {
+            arrayList.clear();
+        }
+
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(1));
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(1));
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(1));
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(9));
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(9));
+        dealerPlayer.getHandTileSet().addTile(new CharacterTile(9));
+        dealerPlayer.getHandTileSet().addTile(new BambooTile(7));
+        dealerPlayer.getHandTileSet().addTile(new BambooTile(8));
+        dealerPlayer.getHandTileSet().addTile(new BambooTile(9));
+        dealerPlayer.getHandTileSet().addTile(new BambooTile(8));
+        dealerPlayer.getHandTileSet().addTile(new BambooTile(8));
+        dealerPlayer.getHandTileSet().addTile(new DotTile(7));
+        dealerPlayer.getHandTileSet().addTile(new DotTile(7));
+        dealerPlayer.getHandTileSet().addTile(new DotTile(7));
+
+        dealerPlayer.getHandTileSet().sort();
+
+        if (PlayerOperateCheckRule.checkCanKong(dealerPlayer)) {
+            dealerPlayer.setCanDarkKong(true);
+        } else {
+            dealerPlayer.setCanDiscard(true);
+        }
+    }
+
+    // Change the turn to the next player
+    public void changePlayer() {
+        int index = 0;
+        int nextIndex = 0;
+        for (Player player : playerList) {
+            if (player.getTurnState()) {
+                index = playerList.indexOf(player);
+                nextIndex = (index + 1) % playerList.size();
+            }
+        }
+        playerList.get(index).setTurnState(false);
+        playerList.get(index).setCanDiscard(false);
+        playerList.get(nextIndex).setTurnState(true);
+
+        if (PlayerOperateCheckRule.checkCanChow(playerList.get(nextIndex), endPlayerDiscardTile)) {
+            playerList.get(nextIndex).setCanChow(true);
+        }
+        playerList.get(nextIndex).setCanGet(true);
+        playerList.get(nextIndex).setCanDarkKong(false);
+    }
+
+    // Handle game logic operations
+    public String logicOperate(String remoteSocketAddress, String operate) {
+        logger.info("------Game Logic Operation Phase------" + operate);
+
+        Player player = null;
+        for (Player p : playerList) {
+            if (Objects.equals(p.getName(), remoteSocketAddress)) {
+                player = p;
+                break;
+            }
+        }
+
+        logger.info("------Found Player------" + player);
+
+        String[] parts = operate.split(" ");
+
+        if (Objects.equals(operate, "Hu")) {
+            logger.info("------Player Wins------" + player);
+
+            player.getHandTileSet().sort();
+            gameState = false;
+            victoryPlayer = player;
+            return "Hu";
+        }
+
+        if (Objects.equals(parts[0], "Discard")) {
+            lastPlayer = player;
+            endPlayerDiscardTile = player.discard(parts[1]);
+            player.getPlayedTileSet().addTile(endPlayerDiscardTile);
+            player.getHandTileSet().sort();
+            logger.info("------Player Discards------" + endPlayerDiscardTile);
+
+            setPlayersPongBrightKongState(endPlayerDiscardTile);
+
+            checkState = true;
+
+            logger.info("------Game Enters Pong/Kong Check State------" + endPlayerDiscardTile);
+
+            return "Discard";
+        }
+
+        if (Objects.equals(parts[0], "Get")) {
+            player.setCanChow(false);
+            player.setCanGet(false);
+
+            endPlayerGetTile = libraryTileSet.discardTile("Tile");
+            player.getTile(endPlayerGetTile);
+            player.getHandTileSet().sort();
+            logger.info("------Player Draws Tile------" + endPlayerDiscardTile);
+
+            setPlayersDarkKongState(player);
+            setHuState(player);
+
+            return "Get";
+        }
+
+        if (Objects.equals(parts[0], "Skip")) {
+            logger.info("------Player Skips Pong/Kong Phase------");
+
+            player.getHandTileSet().sort();
+            player.setSkip(true);
+            player.setCanPong(false);
+            player.setCanBrightKong(false);
+            return "Skip";
+        }
+
+        if (!operate.equals("Chow") && Objects.equals(parts[0], "Chow")) {
+            lastPlayer.getPlayedTileSet().discardTile(endPlayerDiscardTile.toString());
+            player.chow(endPlayerDiscardTile, parts[1]);
+            logger.info("------Player Chows------" + endPlayerDiscardTile);
+
+            player.setCanChow(false);
+            player.setCanGet(false);
+            player.setCanDiscard(true);
+
+            player.getHandTileSet().sort();
+
+            setHuState(player);
+            return "ChowTile";
+        }
+
+        if (Objects.equals(operate, "Chow")) {
+            logger.info("------Player Requests to Chow------" + endPlayerDiscardTile);
+            player.getHandTileSet().sort();
+            return "Chow";
+        }
+
+        if (Objects.equals(parts[0], "Pong")) {
+            lastPlayer.getPlayedTileSet().discardTile(endPlayerDiscardTile.toString());
+            player.pong(endPlayerDiscardTile);
+            logger.info("------Player Pongs------" + endPlayerDiscardTile);
+            Server.skipNumber = 0;
+            resetAllSkip();
+
+            int indexOfPlayerDiscard = 0;
+            for (Player playerDiscard : playerList) {
+                if (playerDiscard.getTurnState()) {
+                    indexOfPlayerDiscard = playerList.indexOf(playerDiscard);
+                }
+            }
+
+            playerList.get(indexOfPlayerDiscard).setTurnState(false);
+            playerList.get(indexOfPlayerDiscard).setCanDiscard(false);
+            player.setTurnState(true);
+            player.setCanChow(false);
+            player.setCanGet(false);
+            player.setCanDiscard(true);
+            player.getHandTileSet().sort();
+            checkState = false;
+            logger.info("------Pong/Kong Check Phase Ends------Player Pongs------" + endPlayerDiscardTile);
+            setHuState(player);
+            return "Pong";
+        }
+
+        if (Objects.equals(parts[0], "Kong")) {
+            if (!player.getTurnState()) {
+                lastPlayer.getPlayedTileSet().discardTile(endPlayerDiscardTile.toString());
+                player.brightKong(endPlayerDiscardTile);
+                kongNumber++;
+                logger.info("------Player Bright Kongs------" + endPlayerDiscardTile);
+                Server.skipNumber = 0;
+                resetAllSkip();
+
+                int indexOfPlayerDiscard = 0;
+                for (Player playerDiscard : playerList) {
+                    if (playerDiscard.getTurnState()) {
+                        indexOfPlayerDiscard = playerList.indexOf(playerDiscard);
+                    }
+                }
+
+                playerList.get(indexOfPlayerDiscard).setTurnState(false);
+                playerList.get(indexOfPlayerDiscard).setCanDiscard(false);
+                player.setTurnState(true);
+                player.setCanChow(false);
+                player.setCanGet(true);
+                player.setCanDiscard(false);
+                player.getHandTileSet().sort();
+                checkState = false;
+                logger.info("------Pong/Kong Check Phase Ends------Player Kongs------" + endPlayerDiscardTile);
+                return "Kong";
+            } else {
+                logger.info("------Player Dark Kongs------" + endPlayerDiscardTile);
+
+                player.Kong();
+                kongNumber++;
+                player.setTurnState(true);
+                player.setCanChow(false);
+                player.setCanGet(true);
+                player.setCanDiscard(false);
+                player.setCanDarkKong(false);
+                player.getHandTileSet().sort();
+
+                return "DarkKong";
+            }
+        }
+        return null;
+    }
+
+    // Set Hu state for a player
+    private void setHuState(Player player) {
+        if (PlayerOperateCheckRule.checkCanHu(player, this)) {
+            player.setCanHu(true);
+        } else {
+            player.setCanHu(false);
+        }
+        logger.info("------Set Player Hu State------" + player.getCanHu());
+    }
+
+    // Set Pong/Bright Kong state for all players
+    private void setPlayersPongBrightKongState(Tile endDiscardTile) {
+        logger.info("------Set All Players Pong/Kong State------" + endPlayerDiscardTile);
+        for (Player player : playerList) {
+            if (PlayerOperateCheckRule.checkCanPong(player, endDiscardTile)) {
+                player.setCanPong(true);
+            } else {
+                player.setCanPong(false);
+            }
+
+            if (PlayerOperateCheckRule.checkCanBrightKong(player, endDiscardTile)) {
+                player.setCanBrightKong(true);
+            } else {
+                player.setCanBrightKong(false);
+            }
+        }
+    }
+
+    // Set Dark Kong state for a player
+    private static void setPlayersDarkKongState(Player player) {
+        if (PlayerOperateCheckRule.checkCanKong(player)) {
+            player.setCanDarkKong(true);
+            player.setCanDiscard(false);
+        } else {
+            player.setCanDarkKong(false);
+            player.setCanDiscard(true);
+        }
+        logger.info("------Set Player Dark Kong and Discard State------" + player.getCanDarkKong() + "------" + player.getCanDiscard());
+    }
+
+    // Reset skip state for all players
+    public void resetAllSkip() {
+        logger.info("------Reset All Players Skip State------");
+        for (Player player : playerList) {
+            player.setSkip(false);
+        }
+    }
+
+    public ArrayList<Player> getPlayerList() {
+        return playerList;
+    }
+
+    public LibraryTileSet getLibraryTileSet() {
+        return libraryTileSet;
+    }
+
+    public boolean getCheckState() {
+        return checkState;
+    }
+
+    public boolean getSelfMo() {
+        return selfMo;
+    }
+
+    public boolean getGameState() {
+        return gameState;
+    }
+
+    public Player getVictoryPlayer() {
+        return victoryPlayer;
+    }
+
+    public Player getLastPlayer() {
+        return lastPlayer;
+    }
+
+    public Tile getEndPlayerDiscardTile() {
+        return endPlayerDiscardTile;
+    }
+
+    public Tile getEndPlayerGetTile() {
+        return endPlayerGetTile;
+    }
+
+    public int getKongNumber() {
+        return kongNumber;
+    }
+
+    public void setCheckState(boolean b) {
+        checkState = b;
+    }
+
+    public void setSelfMo(boolean b) {
+        selfMo = b;
+    }
+
+    // Print detailed information for all players
+    public void printAllPlayersDetails() {
+        synchronized (playerList) {
+            System.out.println("Last discarded tile: " + endPlayerDiscardTile);
+            System.out.println("Last drawn tile: " + endPlayerGetTile);
+            System.out.println("Skip count: " + Server.skipNumber);
+            VictoryCheckRule victoryCheckRule = VictoryCheckRule.getInstance();
+            for (Player player : playerList) {
+                System.out.println("Player details: ");
+                System.out.println(player.getName());
+                System.out.println("Hand Tiles----" + player.getHandTileSet().getTileSets());
+                System.out.println("Locked Tiles----" + player.getLockedTileSet().getTileSets());
+                System.out.println("Played Tiles----" + player.getPlayedTileSet().getTileSets());
+
+                System.out.println("End Get Tile----" + player.getHandTileSet().getEndGetTile());
+                System.out.println("End Kong----" + player.getHandTileSet().getEndKongTile());
+                System.out.println("End Second Get----" + player.getHandTileSet().getEndSecondGetTile());
+                System.out.println("Turn----" + player.getTurnState());
+                System.out.println("Victory Msg----" + player.getName() + "------" + PlayerOperateCheckRule.checkAllVictoryConditions(this, player, victoryCheckRule, ""));
+
+                System.out.println("Get----" + player.getCanGet());
+                System.out.println("Discard----" + player.getCanDiscard());
+                System.out.println("Chow----" + player.getCanChow());
+                System.out.println("Pong----" + player.getCanPong());
+                System.out.println("BKong----" + player.getCanBrightKong());
+                System.out.println("DKong----" + player.getCanDarkKong());
+                System.out.println("Skip----" + player.getSkip());
+            }
+        }
+    }
+}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"588d25d2-c6eb-4329-a34e-48d24e4b82c9\" name=\"Changes\" comment=\"完成基本登陆页面\">\r\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/com/example/mahjong/GameRoomController.java\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/com/example/mahjong/GameRulesController.java\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/src/main/resources/com/example/mahjong/gameRoom.fxml\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/src/main/resources/com/example/mahjong/gameRule.fxml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"FxmlFile\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"master\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 1\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2gaKR81MyzqviTwMkNhOH6KkWPL\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"git-widget-placeholder\": \"Eric\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"last_opened_file_path\": \"C:/Users/董瀚泽/Document/SceneBuilder.exe\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"project.structure.last.edited\": \"Libraries\",\r\n    \"project.structure.proportion\": \"0.0\",\r\n    \"project.structure.side.proportion\": \"0.3207127\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"C:\\Users\\董瀚泽\\Desktop\\Mahjong\\src\\main\\java\\logic\\rules\" />\r\n      <recent name=\"C:\\Users\\董瀚泽\\Desktop\\Mahjong\\src\\main\\java\\logic\\tiles\" />\r\n      <recent name=\"C:\\Users\\董瀚泽\\Desktop\\Mahjong\\src\\main\\java\\logic\\Tiles\" />\r\n      <recent name=\"C:\\Users\\董瀚泽\\Desktop\\Mahjong\\src\\main\\java\\logic\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"588d25d2-c6eb-4329-a34e-48d24e4b82c9\" name=\"Changes\" comment=\"\" />\r\n      <created>1715930239840</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1715930239840</updated>\r\n      <workItem from=\"1715930240922\" duration=\"1016000\" />\r\n      <workItem from=\"1715996477273\" duration=\"1379000\" />\r\n      <workItem from=\"1715999450297\" duration=\"9130000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"完成基本登陆页面\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1716008925896</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1716008925896</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"完成基本登陆页面\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1716009034832</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1716009034832</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"3\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"Eric\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"更改项目结构\" />\r\n    <MESSAGE value=\"完成基本登陆页面\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"完成基本登陆页面\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/.idea/workspace.xml	(date 1717885315170)
@@ -5,10 +5,115 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="588d25d2-c6eb-4329-a34e-48d24e4b82c9" name="Changes" comment="完成基本登陆页面">
-      <change afterPath="$PROJECT_DIR$/src/main/java/com/example/mahjong/GameRoomController.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/java/com/example/mahjong/GameRulesController.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/resources/com/example/mahjong/gameRoom.fxml" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/main/resources/com/example/mahjong/gameRule.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/GameRoomController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/GameRulesController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/MenuController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/OverRoomController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/WaitRoomController.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/com/mmahjong/server/Server.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/DoubleArrayListFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/NonSequenceTilesFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/SequenceTilesFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/SingleArrayListFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/TilesFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/TilesFactoryProducer.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/TilesSetsFactory.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/TilesSetsFactoryProducer.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/factories/test.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/games/Game.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/rules/PlayerOperateCheckRule.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/rules/VictoryCheckRule.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/NonSequenceDecorator.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/SequenceDecorator.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/DoubleArrayListTileDecorator.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/HandTileSet.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/LibraryTileSet.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/LockedTileSet.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/PlayedTileSet.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/SingleArrayListTileDecorator.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/logic/tilesSets/TileSet.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/com/mahjong/client/gameRoom.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/com/mahjong/client/gameRoomWait.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/com/mahjong/client/gameRule.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/com/mahjong/client/menu.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/com/mahjong/client/overRoom.fxml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/images/backGround.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/music/m1.mp3" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/music/m2.mp3" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/music/m3.mp3" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/1Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/1Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/1Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/2Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/2Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/2Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/3Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/3Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/3Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/4Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/4Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/4Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/5Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/5Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/5Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/6Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/6Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/6Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/7Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/7Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/7Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/8Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/8Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/8Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/9Bamboo.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/9Character.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/9Dot.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/East.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/Green.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/North.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/Red.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/South.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/West.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/White.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/resources/tiles/tileBack.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/pom.xml" beforeDir="false" afterPath="$PROJECT_DIR$/pom.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/example/mahjong/Client.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/com/mahjong/client/Client.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/example/mahjong/JoinGameRoomController.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/example/mahjong/LoginController.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/com/example/mahjong/MenuController.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/account/LoginIn.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/account/SignIn.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/data/GetData.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/data/LogData.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameManagement/EventsListener.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameManagement/Game.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameManagement/GameScreen.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameStage/DirectoryStage.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameStage/EndStage.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameStage/PreparatoryStage.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/gameStage/RunStage.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/players/Ai.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/players/GameRole.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/players/Player.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/players/Player.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/rules/Rule.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/rules/Rule.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/rules/ScoringRule.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/rules/ScoringRule.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/rules/VictoryRule.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/rules/test1.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/BambooTile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/BambooTile.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/CharacterTile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/CharacterTile.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/DotTile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/DotTile.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/HandTile.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/HonorTile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/HonorTile.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/LibraryTile.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/PlayedTile.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/Tile.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/logic/tiles/Tile.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/TileSet.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/logic/tiles/test.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/module-info.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/module-info.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/com/example/mahjong/joinGameRoom.fxml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/com/example/mahjong/login.fxml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/resources/com/example/mahjong/menu.fxml" beforeDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -35,37 +140,92 @@
   &quot;associatedIndex&quot;: 1
 }</component>
   <component name="ProjectId" id="2gaKR81MyzqviTwMkNhOH6KkWPL" />
-  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
+  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
+    <ConfirmationsSetting value="2" id="Add" />
+  </component>
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
   <component name="PropertiesComponent"><![CDATA[{
   "keyToString": {
+    "ASKED_ADD_EXTERNAL_FILES": "true",
     "RunOnceActivity.OpenProjectViewOnStart": "true",
     "RunOnceActivity.ShowReadmeOnStart": "true",
     "SHARE_PROJECT_CONFIGURATION_FILES": "true",
     "WebServerToolWindowFactoryState": "false",
     "git-widget-placeholder": "Eric",
     "ignore.virus.scanning.warn.message": "true",
-    "last_opened_file_path": "C:/Users/董瀚泽/Document/SceneBuilder.exe",
+    "last_opened_file_path": "C:/Users/董瀚泽/Desktop/Mahjong/src/main/java/logic/factories",
     "node.js.detected.package.eslint": "true",
     "node.js.detected.package.tslint": "true",
     "node.js.selected.package.eslint": "(autodetect)",
     "node.js.selected.package.tslint": "(autodetect)",
-    "project.structure.last.edited": "Libraries",
-    "project.structure.proportion": "0.0",
+    "project.structure.last.edited": "Modules",
+    "project.structure.proportion": "0.15",
     "project.structure.side.proportion": "0.3207127",
+    "settings.editor.selected.configurable": "preferences.fileTypes",
     "vue.rearranger.settings.migration": "true"
+  },
+  "keyToStringList": {
+    "com.intellij.ide.scratch.ScratchImplUtil$2/New Scratch File": [
+      "CSS"
+    ]
   }
 }]]></component>
   <component name="RecentsManager">
     <key name="CopyFile.RECENT_KEYS">
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\logic\factories" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\com" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main" />
       <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\logic\rules" />
       <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\logic\tiles" />
-      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\logic\Tiles" />
-      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\java\logic" />
     </key>
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\resources\images" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\resources\com\mahjong\client" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\resources\image" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\resources\tiles" />
+      <recent name="C:\Users\董瀚泽\Desktop\Mahjong\src\main\resources\music" />
+    </key>
+  </component>
+  <component name="RunManager" selected="Application.Client">
+    <configuration name="Client" type="Application" factoryName="Application" singleton="false" temporary="true" nameIsGenerated="true">
+      <option name="MAIN_CLASS_NAME" value="com.mahjong.client.Client" />
+      <module name="Mahjong" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="com.mahjong.client.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <configuration name="Server" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
+      <option name="MAIN_CLASS_NAME" value="com.mmahjong.server.Server" />
+      <module name="Mahjong" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="com.mmahjong.server.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
+    <list>
+      <item itemvalue="Application.Client" />
+      <item itemvalue="Application.Server" />
+    </list>
+    <recent_temporary>
+      <list>
+        <item itemvalue="Application.Client" />
+        <item itemvalue="Application.Server" />
+      </list>
+    </recent_temporary>
   </component>
   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
   <component name="TaskManager">
@@ -78,6 +238,28 @@
       <workItem from="1715930240922" duration="1016000" />
       <workItem from="1715996477273" duration="1379000" />
       <workItem from="1715999450297" duration="9130000" />
+      <workItem from="1716113057554" duration="789000" />
+      <workItem from="1716204365336" duration="9222000" />
+      <workItem from="1716258845885" duration="32865000" />
+      <workItem from="1716334497339" duration="22120000" />
+      <workItem from="1716421204187" duration="442000" />
+      <workItem from="1716432543852" duration="5908000" />
+      <workItem from="1716451743634" duration="1874000" />
+      <workItem from="1716453634651" duration="1515000" />
+      <workItem from="1716455166476" duration="10916000" />
+      <workItem from="1716513633420" duration="70207000" />
+      <workItem from="1716657985330" duration="203000" />
+      <workItem from="1716710181020" duration="25981000" />
+      <workItem from="1716865506146" duration="8444000" />
+      <workItem from="1716890942402" duration="62000" />
+      <workItem from="1717302391905" duration="18568000" />
+      <workItem from="1717382516842" duration="7252000" />
+      <workItem from="1717555477823" duration="3924000" />
+      <workItem from="1717640711012" duration="37577000" />
+      <workItem from="1717716055112" duration="57145000" />
+      <workItem from="1717810054230" duration="29501000" />
+      <workItem from="1717845783852" duration="1748000" />
+      <workItem from="1717847551980" duration="32841000" />
     </task>
     <task id="LOCAL-00001" summary="完成基本登陆页面">
       <option name="closed" value="true" />
@@ -95,7 +277,15 @@
       <option name="project" value="LOCAL" />
       <updated>1716009034832</updated>
     </task>
-    <option name="localTasksCounter" value="3" />
+    <task id="LOCAL-00003" summary="完成基本登陆页面">
+      <option name="closed" value="true" />
+      <created>1716113760991</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1716113760991</updated>
+    </task>
+    <option name="localTasksCounter" value="4" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -112,7 +302,7 @@
                   <entry key="branch">
                     <value>
                       <list>
-                        <option value="Eric" />
+                        <option value="master" />
                       </list>
                     </value>
                   </entry>
@@ -125,8 +315,18 @@
     </option>
   </component>
   <component name="VcsManagerConfiguration">
+    <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
     <MESSAGE value="更改项目结构" />
     <MESSAGE value="完成基本登陆页面" />
     <option name="LAST_COMMIT_MESSAGE" value="完成基本登陆页面" />
   </component>
+  <component name="XSLT-Support.FileAssociations.UIState">
+    <expand />
+    <select />
+  </component>
+  <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/Mahjong$Client.ic" NAME="Client Coverage Results" MODIFIED="1717851418485" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="idea" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false">
+      <FILTER>com.mahjong.client.*</FILTER>
+    </SUITE>
+  </component>
 </project>
\ No newline at end of file
Index: src/main/java/logic/factories/TilesSetsFactoryProducer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/TilesSetsFactoryProducer.java b/src/main/java/logic/factories/TilesSetsFactoryProducer.java
new file mode 100644
--- /dev/null	(date 1717779668437)
+++ b/src/main/java/logic/factories/TilesSetsFactoryProducer.java	(date 1717779668437)
@@ -0,0 +1,12 @@
+package logic.factories;
+
+public class TilesSetsFactoryProducer {
+    public static TilesSetsFactory getTilesSetFactory(boolean Single){
+
+        if (Single){
+            return new SingleArrayListFactory();
+        }else {
+            return new DoubleArrayListFactory();
+        }
+    }
+}
Index: src/main/java/logic/factories/DoubleArrayListFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/DoubleArrayListFactory.java b/src/main/java/logic/factories/DoubleArrayListFactory.java
new file mode 100644
--- /dev/null	(date 1717883763416)
+++ b/src/main/java/logic/factories/DoubleArrayListFactory.java	(date 1717883763416)
@@ -0,0 +1,19 @@
+package logic.factories;
+
+import logic.tilesSets.*;
+
+import java.io.Serial;
+
+public class DoubleArrayListFactory extends TilesSetsFactory{
+    @Serial
+    private static final long serialVersionUID = 20L;
+    // HandTile or LockedTile
+    @Override
+    public TileSet getTileSet(String tileSetType) {
+        if (tileSetType.equalsIgnoreCase("HandTile")){
+            return new HandTileSet();
+        }else {
+            return new LockedTileSet();
+        }
+    }
+}
Index: src/main/java/logic/factories/TilesFactoryProducer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/TilesFactoryProducer.java b/src/main/java/logic/factories/TilesFactoryProducer.java
new file mode 100644
--- /dev/null	(date 1717779668363)
+++ b/src/main/java/logic/factories/TilesFactoryProducer.java	(date 1717779668363)
@@ -0,0 +1,12 @@
+package logic.factories;
+
+public class TilesFactoryProducer {
+    public static TilesFactory getTilesFactory(boolean sequence){
+
+        if (sequence){
+            return new SequenceTilesFactory();
+        }else {
+            return new NonSequenceTilesFactory();
+        }
+    }
+}
Index: src/main/java/logic/factories/TilesSetsFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/TilesSetsFactory.java b/src/main/java/logic/factories/TilesSetsFactory.java
new file mode 100644
--- /dev/null	(date 1717779668355)
+++ b/src/main/java/logic/factories/TilesSetsFactory.java	(date 1717779668355)
@@ -0,0 +1,12 @@
+package logic.factories;
+
+import logic.tilesSets.TileSet;
+
+import java.io.Serial;
+import java.io.Serializable;
+
+public abstract class TilesSetsFactory implements Serializable {
+    @Serial
+    private static final long serialVersionUID = 18L;
+    public abstract TileSet getTileSet(String tileSetType);
+}
Index: src/main/java/logic/factories/SingleArrayListFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/SingleArrayListFactory.java b/src/main/java/logic/factories/SingleArrayListFactory.java
new file mode 100644
--- /dev/null	(date 1717883763405)
+++ b/src/main/java/logic/factories/SingleArrayListFactory.java	(date 1717883763405)
@@ -0,0 +1,21 @@
+package logic.factories;
+
+import logic.tilesSets.LibraryTileSet;
+import logic.tilesSets.PlayedTileSet;
+import logic.tilesSets.TileSet;
+
+import java.io.Serial;
+
+public class SingleArrayListFactory extends TilesSetsFactory{
+    @Serial
+    private static final long serialVersionUID = 19L;
+    // Library or Played TileSet
+    @Override
+    public TileSet getTileSet(String tileSetType) {
+        if (tileSetType.equalsIgnoreCase("Library")){
+            return new LibraryTileSet();
+        }else {
+            return new PlayedTileSet();
+        }
+    }
+}
Index: src/main/java/logic/tilesSets/LockedTileSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/LockedTileSet.java b/src/main/java/logic/tilesSets/LockedTileSet.java
new file mode 100644
--- /dev/null	(date 1717779668375)
+++ b/src/main/java/logic/tilesSets/LockedTileSet.java	(date 1717779668375)
@@ -0,0 +1,57 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Objects;
+
+public class LockedTileSet extends DoubleArrayListTileDecorator {
+    @Serial
+    private static final long serialVersionUID = 13L;
+    private ArrayList<ArrayList<Tile>> lockedTileSet;
+    ArrayList<Tile> chowTileSet;
+    ArrayList<Tile> pongTileSet;
+    ArrayList<Tile> brightKongTileSet;
+    ArrayList<Tile> darkKongTileSet;
+    public LockedTileSet(){
+        lockedTileSet = new ArrayList<ArrayList<Tile>>();
+        chowTileSet = new ArrayList<Tile>();
+        pongTileSet = new ArrayList<Tile>();
+        brightKongTileSet = new ArrayList<Tile>();
+        darkKongTileSet = new ArrayList<Tile>();
+        lockedTileSet.add(chowTileSet);
+        lockedTileSet.add(pongTileSet);
+        lockedTileSet.add(brightKongTileSet);
+        lockedTileSet.add(darkKongTileSet);
+        setTileSets(lockedTileSet);
+    }
+
+    @Override
+    public void addTile(Tile tile) {
+        if (Objects.equals(tile.getType(), "Chow")) {
+            chowTileSet.add(tile);
+        }else if (Objects.equals(tile.getType(), "Pong")) {
+            pongTileSet.add(tile);
+        }else if (Objects.equals(tile.getType(), "BrightKong")) {
+            brightKongTileSet.add(tile);
+        }else {
+            darkKongTileSet.add(tile);
+        }
+    }
+
+    @Override
+    public Tile discardTile(String tileType) {
+        return null;
+    }
+
+    @Override
+    public void sort() {
+        Comparator<Tile> tilecomparator = Comparator.comparingInt(Tile::getMagnitude);
+        chowTileSet.sort(tilecomparator);
+        pongTileSet.sort(tilecomparator);
+        brightKongTileSet.sort(tilecomparator);
+        darkKongTileSet.sort(tilecomparator);
+    }
+}
Index: src/main/java/logic/players/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.players;\r\n\r\nimport logic.rules.Rule;\r\nimport logic.tiles.HandTile;\r\nimport logic.tiles.Tile;\r\n\r\npublic class Player implements GameRole {\r\n\r\n    String name;\r\n    HandTile handTile;\r\n    boolean dealerState;\r\n    boolean turnState;\r\n    boolean readyState;\r\n    int scoring;\r\n    Rule rule;\r\n\r\n    Player(String player){\r\n        name = player;\r\n        handTile = new HandTile(name);\r\n        dealerState = false;\r\n        turnState = false;\r\n        readyState = false;\r\n        scoring = 0;\r\n        rule = new Rule();\r\n    }\r\n\r\n\r\n    @Override\r\n    public void discard(Tile tile) {\r\n        handTile.discard(tile);\r\n    }\r\n\r\n    @Override\r\n    public void getTile(Tile tile) {\r\n        handTile.addTile(tile);\r\n    }\r\n\r\n    @Override\r\n    public void changeDealerState() {\r\n        dealerState = !dealerState;\r\n    }\r\n\r\n    @Override\r\n    public void changeTurnState() {\r\n        turnState = !turnState;\r\n    }\r\n\r\n    @Override\r\n    public void changeReadyState() {\r\n        readyState = !readyState;\r\n    }\r\n\r\n\r\n    //依赖rule\r\n    @Override\r\n    public void changeScoring() {\r\n\r\n    }\r\n\r\n    @Override\r\n    public HandTile getHandTile() {\r\n        return handTile;\r\n    }\r\n\r\n    @Override\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    @Override\r\n    public boolean getDealerState() {\r\n        return dealerState;\r\n    }\r\n\r\n    @Override\r\n    public boolean getTurnState() {\r\n        return turnState;\r\n    }\r\n\r\n    @Override\r\n    public boolean getReadyState() {\r\n        return readyState;\r\n    }\r\n\r\n    @Override\r\n    public int getScoring() {\r\n        return scoring;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/players/Player.java b/src/main/java/logic/players/Player.java
--- a/src/main/java/logic/players/Player.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/players/Player.java	(date 1717875945166)
@@ -1,91 +1,322 @@
 package logic.players;
 
+import logic.factories.TilesSetsFactory;
+import logic.factories.TilesSetsFactoryProducer;
 import logic.rules.Rule;
-import logic.tiles.HandTile;
 import logic.tiles.Tile;
+import logic.tilesSets.*;
 
-public class Player implements GameRole {
+import java.io.Serial;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Objects;
 
-    String name;
-    HandTile handTile;
-    boolean dealerState;
-    boolean turnState;
-    boolean readyState;
-    int scoring;
-    Rule rule;
+public class Player implements Serializable {
+    @Serial
+    private static final long serialVersionUID = 21L;
 
-    Player(String player){
+    private HandTileSet handTileSet;
+    private LockedTileSet lockedTileSet;
+    private PlayedTileSet playedTileSet;
+    private String name;
+    private boolean dealerState;
+    private boolean turnState;
+    private boolean canGet;
+    private boolean canDiscard;
+    private boolean canChow;
+    private boolean canPong;
+    private boolean canBrightKong;
+    private boolean canDarkKong;
+    private boolean canHu;
+    private boolean skip;
+    private int scoring;
+
+    // Constructor to initialize a player with a name
+    public Player(String player) {
+        TilesSetsFactory singleArrayListTileSet = TilesSetsFactoryProducer.getTilesSetFactory(true);
+        TilesSetsFactory doubleArrayListTileSet = TilesSetsFactoryProducer.getTilesSetFactory(false);
+        handTileSet = (HandTileSet) doubleArrayListTileSet.getTileSet("HandTile");
+        lockedTileSet = (LockedTileSet) doubleArrayListTileSet.getTileSet("LockedTile");
+        playedTileSet = (PlayedTileSet) singleArrayListTileSet.getTileSet("PlayedTile");
         name = player;
-        handTile = new HandTile(name);
         dealerState = false;
         turnState = false;
-        readyState = false;
+        canGet = false;
+        canDiscard = false;
+        canChow = false;
+        canPong = false;
+        canBrightKong = false;
+        canDarkKong = false;
+        canHu = false;
+        skip = false;
         scoring = 0;
-        rule = new Rule();
     }
 
-
-    @Override
-    public void discard(Tile tile) {
-        handTile.discard(tile);
-    }
-
-    @Override
-    public void getTile(Tile tile) {
-        handTile.addTile(tile);
-    }
-
-    @Override
-    public void changeDealerState() {
-        dealerState = !dealerState;
-    }
-
-    @Override
-    public void changeTurnState() {
-        turnState = !turnState;
-    }
-
-    @Override
-    public void changeReadyState() {
-        readyState = !readyState;
-    }
-
-
-    //依赖rule
-    @Override
-    public void changeScoring() {
-
-    }
-
-    @Override
-    public HandTile getHandTile() {
-        return handTile;
-    }
-
-    @Override
+    // Getters for player states
     public String getName() {
         return name;
     }
 
-    @Override
     public boolean getDealerState() {
         return dealerState;
     }
 
-    @Override
     public boolean getTurnState() {
         return turnState;
     }
 
-    @Override
-    public boolean getReadyState() {
-        return readyState;
+    public boolean getCanGet() {
+        return canGet;
+    }
+
+    public boolean getCanDiscard() {
+        return canDiscard;
+    }
+
+    public boolean getCanChow() {
+        return canChow;
+    }
+
+    public boolean getCanPong() {
+        return canPong;
+    }
+
+    public boolean getCanBrightKong() {
+        return canBrightKong;
+    }
+
+    public boolean getCanDarkKong() {
+        return canDarkKong;
     }
 
-    @Override
+    public boolean getCanHu() {
+        return canHu;
+    }
+
+    public boolean getSkip() {
+        return skip;
+    }
+
     public int getScoring() {
         return scoring;
     }
 
+    // Setters for player states
+    public void setDealerState(boolean b) {
+        dealerState = b;
+    }
+
+    public void setTurnState(boolean b) {
+        turnState = b;
+    }
+
+    public void setCanGet(boolean b) {
+        canGet = b;
+    }
+
+    public void setCanDiscard(boolean b) {
+        canDiscard = b;
+    }
 
+    public void setCanChow(boolean b) {
+        canChow = b;
+    }
+
+    public void setCanPong(boolean b) {
+        canPong = b;
+    }
+
+    public void setCanBrightKong(boolean b) {
+        canBrightKong = b;
+    }
+
+    public void setCanDarkKong(boolean b) {
+        canDarkKong = b;
+    }
+
+    public void setCanHu(boolean b) {
+        canHu = b;
+    }
+
+    public void setScoring(int s) {
+        scoring = s;
+    }
+
+    public void setSkip(boolean b) {
+        skip = b;
+    }
+
+    // Player actions
+    public void getTile(Tile tile) {
+        handTileSet.addTile(tile);
+    }
+
+    public Tile discard(String tileType) {
+        return handTileSet.discardTile(tileType);
+    }
+
+    public void chow(Tile tile, String type) {
+        handTileSet.setEndSecondGetTile(handTileSet.getEndGetTile());
+        handTileSet.setEndGetTile(tile);
+
+        ArrayList<Tile> targetSubHandTileSet = null;
+        targetSubHandTileSet = setTargetSubHandTileSet(handTileSet.getTileSets(), tile, targetSubHandTileSet);
+        chowByTypes(tile, type, targetSubHandTileSet, lockedTileSet);
+    }
+
+    private ArrayList<Tile> setTargetSubHandTileSet(ArrayList<ArrayList<Tile>> handTileSets, Tile tile, ArrayList<Tile> targetTileSet) {
+        String tileType = tile.getType();
+        if (tileType.equals("Character")) {
+            targetTileSet = handTileSets.get(0);
+        } else if (tileType.equals("Bamboo")) {
+            targetTileSet = handTileSets.get(1);
+        } else if (tileType.equals("Dot")) {
+            targetTileSet = handTileSets.get(2);
+        }
+        return targetTileSet;
+    }
+
+    private void chowByTypes(Tile tile, String type, ArrayList<Tile> targetTileSet, LockedTileSet lockedTileSets) {
+        int magnitude = tile.getMagnitude();
+        ArrayList<Tile> removedTile;
+        ArrayList<Tile> chowTileSet = lockedTileSets.getTileSets().get(0);
+        boolean check1 = false;
+        boolean check2 = false;
+
+        if (Objects.equals(type, "1")) {
+            removedTile = new ArrayList<>();
+            for (Tile targetTile : targetTileSet) {
+                if (targetTile.getMagnitude() == magnitude - 1 && !check1) {
+                    chowTileSet.add(targetTile);
+                    removedTile.add(targetTile);
+                    check1 = true;
+                }
+                if (targetTile.getMagnitude() == magnitude - 2 && !check2) {
+                    chowTileSet.add(targetTile);
+                    removedTile.add(targetTile);
+                    check2 = true;
+                }
+            }
+            targetTileSet.removeAll(removedTile);
+            chowTileSet.add(tile);
+        } else if (Objects.equals(type, "2")) {
+            removedTile = new ArrayList<>();
+            for (Tile targetTile : targetTileSet) {
+                if (targetTile.getMagnitude() == magnitude - 1 && !check1) {
+                    chowTileSet.add(targetTile);
+                    chowTileSet.add(tile);
+                    removedTile.add(targetTile);
+                    check1 = true;
+                }
+                if (targetTile.getMagnitude() == magnitude + 1 && !check2) {
+                    chowTileSet.add(targetTile);
+                    removedTile.add(targetTile);
+                    check2 = true;
+                }
+            }
+            targetTileSet.removeAll(removedTile);
+        } else if (Objects.equals(type, "3")) {
+            removedTile = new ArrayList<>();
+            chowTileSet.add(tile);
+            for (Tile targetTile : targetTileSet) {
+                if (targetTile.getMagnitude() == magnitude + 1 && !check1) {
+                    chowTileSet.add(targetTile);
+                    removedTile.add(targetTile);
+                    check1 = true;
+                }
+                if (targetTile.getMagnitude() == magnitude + 2 && !check2) {
+                    chowTileSet.add(targetTile);
+                    removedTile.add(targetTile);
+                    check2 = true;
+                }
+            }
+            targetTileSet.removeAll(removedTile);
+        }
+    }
+
+    public void pong(Tile tile) {
+        handTileSet.setEndSecondGetTile(handTileSet.getEndGetTile());
+        handTileSet.setEndGetTile(tile);
+        ArrayList<Tile> pongTileSet = lockedTileSet.getTileSets().get(1);
+        pongTileSet.add(tile);
+
+        int count = 0;
+        for (ArrayList<Tile> tileSet : handTileSet.getTileSets()) {
+            ArrayList<Tile> removedTile = new ArrayList<>();
+            for (Tile targetTile : tileSet) {
+                if (Objects.equals(targetTile.getType(), tile.getType()) && targetTile.getMagnitude() == tile.getMagnitude()) {
+                    if (count < 2) {
+                        count++;
+                        pongTileSet.add(targetTile);
+                        removedTile.add(targetTile);
+                    }
+                }
+            }
+            tileSet.removeAll(removedTile);
+        }
+    }
+
+    public void brightKong(Tile tile) {
+        handTileSet.setEndSecondGetTile(handTileSet.getEndGetTile());
+        handTileSet.setEndGetTile(tile);
+        handTileSet.setEndKongTile(tile);
+        ArrayList<Tile> brightKongTileSet = lockedTileSet.getTileSets().get(2);
+        brightKongTileSet.add(tile);
+
+        int count = 0;
+        for (ArrayList<Tile> tileSet : handTileSet.getTileSets()) {
+            ArrayList<Tile> removedTile = new ArrayList<>();
+            for (Tile targetTile : tileSet) {
+                if (Objects.equals(targetTile.getType(), tile.getType()) && targetTile.getMagnitude() == tile.getMagnitude()) {
+                    if (count < 3) {
+                        count++;
+                        brightKongTileSet.add(targetTile);
+                        removedTile.add(targetTile);
+                    }
+                }
+            }
+            tileSet.removeAll(removedTile);
+        }
+    }
+
+    public void Kong() {
+        darkKong();
+    }
+
+    private void darkKong() {
+        Rule rule = Rule.getInstance();
+        ArrayList<Tile> newKongSet = new ArrayList<>();
+        ArrayList<Tile> kongSet = lockedTileSet.getTileSets().get(3);
+        for (ArrayList<Tile> tileArrayList : handTileSet.getTileSets()) {
+            newKongSet.addAll(rule.checkKong(tileArrayList));
+        }
+        int count = 0;
+        for (ArrayList<Tile> tileSet : handTileSet.getTileSets()) {
+            ArrayList<Tile> removedTile = new ArrayList<>();
+            for (Tile tile : tileSet) {
+                if (Objects.equals(tile.getType(), newKongSet.get(0).getType()) && tile.getMagnitude() == newKongSet.get(0).getMagnitude()) {
+                    if (count < 4) {
+                        count++;
+                        handTileSet.setEndKongTile(tile);
+                        kongSet.add(tile);
+                        removedTile.add(tile);
+                    }
+                }
+            }
+            tileSet.removeAll(removedTile);
+        }
+    }
+
+    // Getters for player's tile sets
+    public HandTileSet getHandTileSet() {
+        return handTileSet;
+    }
+
+    public LockedTileSet getLockedTileSet() {
+        return lockedTileSet;
+    }
+
+    public PlayedTileSet getPlayedTileSet() {
+        return playedTileSet;
+    }
 }
Index: src/main/java/logic/tilesSets/PlayedTileSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/PlayedTileSet.java b/src/main/java/logic/tilesSets/PlayedTileSet.java
new file mode 100644
--- /dev/null	(date 1717779668359)
+++ b/src/main/java/logic/tilesSets/PlayedTileSet.java	(date 1717779668359)
@@ -0,0 +1,24 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.util.ArrayList;
+import java.util.Collections;
+
+public class PlayedTileSet extends SingleArrayListTileDecorator {
+    @Serial
+    private static final long serialVersionUID = 12L;
+    private ArrayList<Tile> playedTileSet;
+
+    public PlayedTileSet(){
+        playedTileSet = new ArrayList<Tile>();
+        setTileSets(playedTileSet);
+        setTileNumber(playedTileSet.size());
+    }
+
+    @Override
+    public void sort() {
+        Collections.shuffle(playedTileSet);
+    }
+}
Index: src/main/java/logic/tilesSets/HandTileSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/HandTileSet.java b/src/main/java/logic/tilesSets/HandTileSet.java
new file mode 100644
--- /dev/null	(date 1717789031117)
+++ b/src/main/java/logic/tilesSets/HandTileSet.java	(date 1717789031117)
@@ -0,0 +1,89 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Objects;
+
+public class HandTileSet extends DoubleArrayListTileDecorator {
+    @Serial
+    private static final long serialVersionUID = 14L;
+    private ArrayList<ArrayList<Tile>> handTileSet;
+    ArrayList<Tile> character;
+    ArrayList<Tile> bamboo;
+    ArrayList<Tile> dot;
+    ArrayList<Tile> honor;
+    Tile endGetTile;
+    Tile endSecondGetTile;
+    Tile endKongTile;
+    public HandTileSet(){
+        handTileSet = new ArrayList<ArrayList<Tile>>();
+        character = new ArrayList<Tile>();
+        bamboo = new ArrayList<Tile>();
+        dot = new ArrayList<Tile>();
+        honor = new ArrayList<Tile>();
+        handTileSet.add(character);
+        handTileSet.add(bamboo);
+        handTileSet.add(dot);
+        handTileSet.add(honor);
+        endGetTile = null;
+        endSecondGetTile = null;
+        endKongTile = null;
+        setTileSets(handTileSet);
+    }
+    @Override
+    public void addTile(Tile tile) {
+        endSecondGetTile = endGetTile;
+        endGetTile = tile;
+        if (Objects.equals(tile.getType(), "Character")) {
+            character.add(tile);
+        }else if (Objects.equals(tile.getType(), "Bamboo")) {
+            bamboo.add(tile);
+        }else if (Objects.equals(tile.getType(), "Dot")) {
+            dot.add(tile);
+        }else {
+            honor.add(tile);
+        }
+    }
+
+    @Override
+    public Tile discardTile(String tileType) {
+        for (ArrayList<Tile> tileSet: handTileSet){
+            for (Tile tile: tileSet){
+                if (Objects.equals(tile.toString(), tileType)){
+                    tileSet.remove(tile);
+                    return tile;
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public void sort() {
+        character.sort(null);
+        bamboo.sort(null);
+        dot.sort(null);
+        honor.sort(null);
+    }
+    public Tile getEndGetTile(){
+        return endGetTile;
+    }
+    public Tile getEndSecondGetTile(){
+        return endSecondGetTile;
+    }
+    public Tile getEndKongTile(){
+        return endKongTile;
+    }
+    public void setEndGetTile(Tile tile){
+        endGetTile = tile;
+    }
+    public void setEndSecondGetTile(Tile tile){
+        endSecondGetTile = tile;
+    }
+    public void setEndKongTile(Tile tile){
+        endKongTile = tile;
+    }
+}
Index: src/main/java/logic/tilesSets/DoubleArrayListTileDecorator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/DoubleArrayListTileDecorator.java b/src/main/java/logic/tilesSets/DoubleArrayListTileDecorator.java
new file mode 100644
--- /dev/null	(date 1717883763437)
+++ b/src/main/java/logic/tilesSets/DoubleArrayListTileDecorator.java	(date 1717883763437)
@@ -0,0 +1,56 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.util.ArrayList;
+
+abstract class DoubleArrayListTileDecorator extends TileSet{
+    @Serial
+    private static final long serialVersionUID = 10L;
+    private TileSet<ArrayList<Tile>> tileSet;
+    private int tileNumber;
+    // HandTile or LockedTile
+    DoubleArrayListTileDecorator() {
+        tileSet = new TileSet<ArrayList<Tile>>() {
+            @Override
+            public void addTile(Tile tile) {
+
+            }
+
+            @Override
+            public Tile discardTile(String tileType) {
+                return null;
+            }
+
+            @Override
+            public void sort() {
+
+            }
+        };
+    }
+
+    @Override
+    public void setTileSets(ArrayList tileSets){
+        tileSet.setTileSets(tileSets);
+    }
+    @Override
+    public void setTileNumber(int tileNumber){
+        this.tileNumber = tileNumber;
+        tileSet.setTileNumber(tileNumber);
+    }
+    @Override
+    public ArrayList<ArrayList<Tile>> getTileSets(){
+        return tileSet.getTileSets();
+    }
+    @Override
+    public int getTileNumber(){
+        int numbers = 0;
+        for (ArrayList<Tile> arrayList: tileSet.getTileSets()){
+            for (Tile tile: arrayList){
+                numbers++;
+            }
+        }
+        return numbers;
+    }
+}
Index: src/main/java/logic/tilesSets/LibraryTileSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/LibraryTileSet.java b/src/main/java/logic/tilesSets/LibraryTileSet.java
new file mode 100644
--- /dev/null	(date 1717779668401)
+++ b/src/main/java/logic/tilesSets/LibraryTileSet.java	(date 1717779668401)
@@ -0,0 +1,40 @@
+package logic.tilesSets;
+
+import logic.factories.TilesFactory;
+import logic.factories.TilesFactoryProducer;
+
+import java.io.Serial;
+import java.util.ArrayList;
+import java.util.Collections;
+
+public class LibraryTileSet extends SingleArrayListTileDecorator {
+    @Serial
+    private static final long serialVersionUID = 11L;
+    private ArrayList<logic.tiles.Tile> libraryTileSet;
+    public LibraryTileSet(){
+        TilesFactory sequenceTilesProducer = TilesFactoryProducer.getTilesFactory(true);
+        TilesFactory nonSequenceTilesProducer = TilesFactoryProducer.getTilesFactory(false);
+        libraryTileSet = new ArrayList<logic.tiles.Tile>();
+        String[] tileTypes = {"1Character","2Character","3Character","4Character","5Character","6Character","7Character",
+                "8Character","9Character", "1Bamboo","2Bamboo","3Bamboo","4Bamboo","5Bamboo","6Bamboo","7Bamboo","8Bamboo",
+                "9Bamboo", "1Dot","2Dot","3Dot","4Dot","5Dot","6Dot","7Dot","8Dot","9Dot","East","West","South","North",
+                "Red","Green","White"};
+        for (int i = 0; i < 4; ++i){
+            for (int j = 0; j < 34;++j){
+                if (j<=26){
+                    libraryTileSet.add(sequenceTilesProducer.getTile(tileTypes[j]));
+                }else{
+                    libraryTileSet.add(nonSequenceTilesProducer.getTile(tileTypes[j]));
+                }
+            }
+        }
+        setTileSets(libraryTileSet);
+        setTileNumber(libraryTileSet.size());
+    }
+
+
+    @Override
+    public void sort() {
+        Collections.shuffle(libraryTileSet);
+    }
+}
Index: src/main/java/logic/tilesSets/TileSet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/TileSet.java b/src/main/java/logic/tilesSets/TileSet.java
new file mode 100644
--- /dev/null	(date 1717779668386)
+++ b/src/main/java/logic/tilesSets/TileSet.java	(date 1717779668386)
@@ -0,0 +1,32 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.io.Serializable;
+import java.util.ArrayList;
+
+public abstract class TileSet<T> implements Serializable {
+    @Serial
+    private static final long serialVersionUID = 8L;
+    private ArrayList<T> tileSets;
+    private int tileNumber;
+    abstract public void addTile(Tile tile);
+    abstract public Tile discardTile(String tileType);
+
+//    abstract public Tile discardTile(Tile tile);
+    abstract public void sort();
+
+    public void setTileSets(ArrayList<T> tileSets){
+        this.tileSets = tileSets;
+    }
+    public void setTileNumber(int tileNumber){
+        this.tileNumber = tileNumber;
+    }
+    public ArrayList<T> getTileSets(){
+        return tileSets;
+    }
+    public int getTileNumber(){
+        return tileNumber;
+    }
+}
Index: src/main/java/logic/tilesSets/SingleArrayListTileDecorator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tilesSets/SingleArrayListTileDecorator.java b/src/main/java/logic/tilesSets/SingleArrayListTileDecorator.java
new file mode 100644
--- /dev/null	(date 1717883763427)
+++ b/src/main/java/logic/tilesSets/SingleArrayListTileDecorator.java	(date 1717883763427)
@@ -0,0 +1,65 @@
+package logic.tilesSets;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.util.ArrayList;
+
+abstract class SingleArrayListTileDecorator extends TileSet{
+    @Serial
+    private static final long serialVersionUID = 9L;
+    private TileSet<logic.tiles.Tile> tileSet;
+    private int tileNumber;
+    // Library or PLayed TileSet
+    SingleArrayListTileDecorator() {
+        tileSet = new TileSet<Tile>() {
+            @Override
+            public void addTile(Tile tile) {
+
+            }
+
+            @Override
+            public Tile discardTile(String tileType) {
+                return null;
+            }
+
+            @Override
+            public void sort() {
+
+            }
+        };
+    }
+
+    @Override
+    public void setTileSets(ArrayList tileSets){
+        tileSet.setTileSets(tileSets);
+    }
+    @Override
+    public void setTileNumber(int tileNumber){
+        this.tileNumber = tileNumber;
+        tileSet.setTileNumber(tileNumber);
+    }
+    @Override
+    public ArrayList<Tile> getTileSets(){
+        return tileSet.getTileSets();
+    }
+    @Override
+    public int getTileNumber(){
+        return tileSet.getTileNumber();
+    }
+
+    @Override
+    public void addTile(logic.tiles.Tile tile){
+        tileSet.getTileSets().add(tile);
+        tileNumber++;
+        this.setTileNumber(tileNumber);
+    }
+    @Override
+    public Tile discardTile(String tileType) {
+        tileNumber--;
+        this.setTileNumber(tileNumber);
+        return tileSet.getTileSets().remove(tileSet.getTileSets().size()-1);
+    }
+
+
+}
Index: src/main/java/logic/factories/NonSequenceTilesFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/NonSequenceTilesFactory.java b/src/main/java/logic/factories/NonSequenceTilesFactory.java
new file mode 100644
--- /dev/null	(date 1717883763419)
+++ b/src/main/java/logic/factories/NonSequenceTilesFactory.java	(date 1717883763419)
@@ -0,0 +1,31 @@
+package logic.factories;
+
+import logic.tiles.HonorTile;
+import logic.tiles.Tile;
+
+import java.io.Serial;
+
+public class NonSequenceTilesFactory extends TilesFactory{
+    @Serial
+    private static final long serialVersionUID = 17L;
+    // Red White Green East West South North
+    @Override
+    public Tile getTile(String tileType) {
+        if (tileType.equalsIgnoreCase("East")){
+            return new HonorTile("East");
+        }else if (tileType.equalsIgnoreCase("South")){
+            return new HonorTile("South");
+        }else if (tileType.equalsIgnoreCase("West")){
+            return new HonorTile("West");
+        }else if (tileType.equalsIgnoreCase("North")){
+            return new HonorTile("North");
+        }else if (tileType.equalsIgnoreCase("Red")){
+            return new HonorTile("Red");
+        }else if (tileType.equalsIgnoreCase("Green")){
+            return new HonorTile("Green");
+        }else if (tileType.equalsIgnoreCase("White")){
+            return new HonorTile("White");
+        }
+        return null;
+    }
+}
Index: src/main/resources/com/mahjong/client/menu.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/com/mahjong/client/menu.fxml b/src/main/resources/com/mahjong/client/menu.fxml
new file mode 100644
--- /dev/null	(date 1717879331661)
+++ b/src/main/resources/com/mahjong/client/menu.fxml	(date 1717879331661)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.layout.VBox?>
+<?import javafx.scene.text.Font?>
+<?import javafx.scene.text.Text?>
+
+<VBox fx:id="vbox" alignment="CENTER" spacing="20" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/21" fx:controller="com.mahjong.client.MenuController">
+    <Text text="Mahjong">
+      <font>
+         <Font size="30.0" />
+      </font></Text>
+    <Button fx:id="gameStartButton" onAction="#handleGameStart" text="Game Start">
+      <font>
+         <Font size="20.0" />
+      </font></Button>
+    <Button fx:id="gameRulesButton" onAction="#handleGameRules" text="Game Rule">
+      <font>
+         <Font size="20.0" />
+      </font></Button>
+    <Button fx:id="exitGameButton" onAction="#handleExitGame" prefHeight="40.0" prefWidth="129.0" text="Exit">
+      <font>
+         <Font size="20.0" />
+      </font></Button>
+</VBox>
Index: src/main/java/logic/factories/TilesFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/TilesFactory.java b/src/main/java/logic/factories/TilesFactory.java
new file mode 100644
--- /dev/null	(date 1717779668330)
+++ b/src/main/java/logic/factories/TilesFactory.java	(date 1717779668330)
@@ -0,0 +1,12 @@
+package logic.factories;
+
+import logic.tiles.Tile;
+
+import java.io.Serial;
+import java.io.Serializable;
+
+public abstract class TilesFactory implements Serializable {
+    @Serial
+    private static final long serialVersionUID = 15L;
+    public abstract Tile getTile(String tileType);
+}
Index: src/main/resources/com/mahjong/client/gameRule.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/com/mahjong/client/gameRule.fxml b/src/main/resources/com/mahjong/client/gameRule.fxml
new file mode 100644
--- /dev/null	(date 1717885168645)
+++ b/src/main/resources/com/mahjong/client/gameRule.fxml	(date 1717885168645)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.TextArea?>
+<?import javafx.scene.layout.VBox?>
+<?import javafx.scene.text.Font?>
+<?import javafx.scene.text.Text?>
+
+<VBox fx:id="rulesVBox" alignment="CENTER" spacing="20" xmlns:fx="http://javafx.com/fxml/1" xmlns="http://javafx.com/javafx/21" fx:controller="com.mahjong.client.GameRulesController">
+    <Text text="Mahjong Rules">
+        <font>
+            <Font size="30.0" />
+        </font>
+    </Text>
+    <TextArea fx:id="rulesTextArea" editable="false" text="" wrapText="true">
+        <font>
+            <Font size="14.0" />
+        </font>
+    </TextArea>
+    <Button fx:id="returnButton" onAction="#handleReturn" text="Back">
+        <font>
+            <Font size="14.0" />
+        </font>
+    </Button>
+</VBox>
\ No newline at end of file
Index: src/main/java/logic/factories/SequenceTilesFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/factories/SequenceTilesFactory.java b/src/main/java/logic/factories/SequenceTilesFactory.java
new file mode 100644
--- /dev/null	(date 1717883763409)
+++ b/src/main/java/logic/factories/SequenceTilesFactory.java	(date 1717883763409)
@@ -0,0 +1,73 @@
+package logic.factories;
+
+import logic.tiles.BambooTile;
+import logic.tiles.CharacterTile;
+import logic.tiles.DotTile;
+import logic.tiles.Tile;
+
+import java.io.Serial;
+
+public class SequenceTilesFactory extends TilesFactory{
+    @Serial
+    private static final long serialVersionUID = 16L;
+    // Character, Bamboo, Dot
+    @Override
+    public Tile getTile(String tileType){
+        if (tileType.equalsIgnoreCase("1Character")){
+            return new CharacterTile(1);
+        }else if (tileType.equalsIgnoreCase("2Character")){
+            return new CharacterTile(2);
+        }else if (tileType.equalsIgnoreCase("3Character")){
+            return new CharacterTile(3);
+        }else if (tileType.equalsIgnoreCase("4Character")){
+            return new CharacterTile(4);
+        }else if (tileType.equalsIgnoreCase("5Character")){
+            return new CharacterTile(5);
+        }else if (tileType.equalsIgnoreCase("6Character")){
+            return new CharacterTile(6);
+        }else if (tileType.equalsIgnoreCase("7Character")){
+            return new CharacterTile(7);
+        }else if (tileType.equalsIgnoreCase("8Character")){
+            return new CharacterTile(8);
+        }else if (tileType.equalsIgnoreCase("9Character")){
+            return new CharacterTile(9);
+        }else if (tileType.equalsIgnoreCase("1Bamboo")){
+            return new BambooTile(1);
+        }else if (tileType.equalsIgnoreCase("2Bamboo")){
+            return new BambooTile(2);
+        }else if (tileType.equalsIgnoreCase("3Bamboo")){
+            return new BambooTile(3);
+        }else if (tileType.equalsIgnoreCase("4Bamboo")){
+            return new BambooTile(4);
+        }else if (tileType.equalsIgnoreCase("5Bamboo")){
+            return new BambooTile(5);
+        }else if (tileType.equalsIgnoreCase("6Bamboo")){
+            return new BambooTile(6);
+        }else if (tileType.equalsIgnoreCase("7Bamboo")){
+            return new BambooTile(7);
+        }else if (tileType.equalsIgnoreCase("8Bamboo")){
+            return new BambooTile(8);
+        }else if (tileType.equalsIgnoreCase("9Bamboo")){
+            return new BambooTile(9);
+        }else if (tileType.equalsIgnoreCase("1Dot")){
+            return new DotTile(1);
+        }else if (tileType.equalsIgnoreCase("2Dot")){
+            return new DotTile(2);
+        }else if (tileType.equalsIgnoreCase("3Dot")){
+            return new DotTile(3);
+        }else if (tileType.equalsIgnoreCase("4Dot")){
+            return new DotTile(4);
+        }else if (tileType.equalsIgnoreCase("5Dot")){
+            return new DotTile(5);
+        }else if (tileType.equalsIgnoreCase("6Dot")){
+            return new DotTile(6);
+        }else if (tileType.equalsIgnoreCase("7Dot")){
+            return new DotTile(7);
+        }else if (tileType.equalsIgnoreCase("8Dot")){
+            return new DotTile(8);
+        }else if (tileType.equalsIgnoreCase("9Dot")){
+            return new DotTile(9);
+        }
+        return null;
+    }
+}
Index: src/main/resources/com/mahjong/client/gameRoom.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/com/mahjong/client/gameRoom.fxml b/src/main/resources/com/mahjong/client/gameRoom.fxml
new file mode 100644
--- /dev/null	(date 1717879240945)
+++ b/src/main/resources/com/mahjong/client/gameRoom.fxml	(date 1717879240945)
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.geometry.Insets?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.Label?>
+<?import javafx.scene.layout.BorderPane?>
+<?import javafx.scene.layout.HBox?>
+<?import javafx.scene.layout.TilePane?>
+<?import javafx.scene.layout.VBox?>
+<?import javafx.scene.text.Font?>
+
+<BorderPane fx:id="rootPane" styleClass="root-pane" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.mahjong.client.GameRoomController">
+    <top>
+        <HBox alignment="CENTER" prefHeight="180.0" prefWidth="800.0" spacing="5" styleClass="hbox">
+            <padding>
+                <Insets bottom="10" left="10" right="10" top="10" />
+            </padding>
+            <VBox spacing="5" styleClass="vbox">
+                <Label fx:id="playerLabel3" alignment="TOP_LEFT" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="dealerLabel3" alignment="TOP_LEFT" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="turnLabel3" alignment="TOP_LEFT" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <HBox fx:id="player3HandTiles" alignment="CENTER" prefHeight="90.0" prefWidth="500.0" spacing="5">
+                </HBox>
+                <HBox fx:id="player3LockedTiles" alignment="CENTER" prefHeight="90.0" prefWidth="500.0" spacing="5">
+                </HBox>
+            </VBox>
+        </HBox>
+    </top>
+    <left>
+        <VBox alignment="CENTER" prefHeight="440.0" prefWidth="180.0" spacing="5" styleClass="vbox">
+            <VBox styleClass="vbox">
+                <padding>
+                    <Insets bottom="10" left="10" right="10" top="10" />
+                </padding>
+                <Label fx:id="playerLabel4" alignment="CENTER" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="dealerLabel4" alignment="CENTER" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="turnLabel4" alignment="CENTER" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+            </VBox>
+            <HBox styleClass="hbox">
+                <VBox fx:id="player4HandTiles" alignment="CENTER" prefHeight="300.0" prefWidth="90.0" spacing="5" styleClass="vbox">
+                </VBox>
+                <VBox fx:id="player4LockedTiles" alignment="CENTER" prefHeight="300.0" prefWidth="90.0" spacing="5" styleClass="vbox">
+                </VBox>
+            </HBox>
+        </VBox>
+    </left>
+    <right>
+        <VBox alignment="CENTER" prefHeight="440.0" prefWidth="180.0" spacing="5" styleClass="vbox">
+            <VBox alignment="CENTER_LEFT" nodeOrientation="RIGHT_TO_LEFT" styleClass="vbox">
+                <padding>
+                    <Insets bottom="10" left="10" right="10" top="10" />
+                </padding>
+                <Label fx:id="playerLabel2" alignment="TOP_RIGHT" contentDisplay="RIGHT" text="" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="dealerLabel2" alignment="TOP_RIGHT" contentDisplay="RIGHT" text="" textAlignment="RIGHT" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+                <Label fx:id="turnLabel2" alignment="TOP_RIGHT" contentDisplay="RIGHT" text="" textAlignment="RIGHT" textFill="#a92e54">
+               <font>
+                  <Font size="20.0" />
+               </font></Label>
+            </VBox>
+            <HBox styleClass="hbox">
+                <VBox fx:id="player2LockedTiles" alignment="CENTER" prefHeight="300.0" prefWidth="90.0" spacing="5" styleClass="vbox">
+                </VBox>
+                <VBox fx:id="player2HandTiles" alignment="CENTER" prefHeight="300.0" prefWidth="90.0" spacing="5">
+                </VBox>
+            </HBox>
+        </VBox>
+    </right>
+    <bottom>
+        <VBox prefHeight="180.0" prefWidth="800.0" spacing="5" styleClass="vbox">
+            <padding>
+                <Insets bottom="10" left="10" right="10" top="10" />
+            </padding>
+            <Label fx:id="playerLabel1" alignment="TOP_LEFT" text="" textFill="#a92e54">
+            <font>
+               <Font size="20.0" />
+            </font></Label>
+            <Label fx:id="dealerLabel1" alignment="TOP_LEFT" text="" textFill="#a92e54">
+            <font>
+               <Font size="20.0" />
+            </font></Label>
+            <Label fx:id="turnLabel1" alignment="TOP_LEFT" text="" textFill="#a92e54">
+            <font>
+               <Font size="20.0" />
+            </font></Label>
+            <HBox fx:id="player1LockedTiles" alignment="CENTER" spacing="5" styleClass="hbox">
+            </HBox>
+            <HBox fx:id="player1Tiles" alignment="CENTER" spacing="5" styleClass="hbox">
+            </HBox>
+            <HBox alignment="CENTER" spacing="20" styleClass="hbox">
+                <Button fx:id="Chow" minWidth="70" onAction="#handleChow" text="Chow" />
+                <Button fx:id="Pong" minWidth="70" onAction="#handlePong" text="Pong" />
+                <Button fx:id="Kong" minWidth="70" onAction="#handleKong" text="Kong" />
+                <Button fx:id="Get" minWidth="70" onAction="#handleGet" text="Get" />
+                <Button fx:id="Discard" minWidth="70" onAction="#handleDiscard" text="Discard" />
+                <Button fx:id="Skip" minWidth="70" onAction="#handleSkip" text="Skip" />
+                <Button fx:id="Hint" minWidth="70" onAction="#handleHint" text="Hint" />
+                <Button fx:id="Hu" minWidth="70" onAction="#handleHu" text="Hu" />
+                <Button minWidth="70" onAction="#handlePrevious" text="Prev" />
+                <Button fx:id="Music" minWidth="70" onAction="#handleMusic" text="Music" />
+                <Button minWidth="70" onAction="#handleNext" text="Next" />
+            </HBox>
+        </VBox>
+    </bottom>
+    <center>
+        <BorderPane fx:id="gameBoard" prefHeight="500.0" prefWidth="500.0" BorderPane.alignment="CENTER">
+            <top>
+                <TilePane fx:id="topTilePane" alignment="TOP_LEFT" orientation="HORIZONTAL" prefHeight="100.0" prefWidth="300.0" style="-fx-background-color: rgba(23,81,128,0);" BorderPane.alignment="CENTER">
+                    <children>
+                    </children>
+                </TilePane>
+            </top>
+            <left>
+                <TilePane fx:id="leftTilePane" alignment="TOP_LEFT" orientation="VERTICAL" prefHeight="250.0" prefWidth="120.0" style="-fx-background-color: rgba(23,81,128,0);" BorderPane.alignment="CENTER">
+                    <children>
+                    </children>
+                </TilePane>
+            </left>
+            <right>
+                <TilePane fx:id="rightTilePane" alignment="TOP_RIGHT" orientation="VERTICAL" prefHeight="250.0" prefWidth="120.0" style="-fx-background-color: rgba(23,81,128,0);" BorderPane.alignment="CENTER">
+                    <children>
+                    </children>
+                </TilePane>
+            </right>
+            <bottom>
+                <TilePane fx:id="bottomTilePane" alignment="BOTTOM_LEFT" orientation="HORIZONTAL" prefHeight="100.0" prefWidth="300.0" style="-fx-background-color: rgba(23,81,128,0);" BorderPane.alignment="CENTER">
+                    <children>
+                    </children>
+                </TilePane>
+            </bottom>
+            <center>
+                <Label fx:id="autoHideLabel" alignment="CENTER" text="" textFill="#a92e54" visible="false" />
+            </center>
+            <VBox fx:id="chowOptionsVBox" alignment="CENTER" layoutX="150" layoutY="200" spacing="10" styleClass="vbox" visible="false" />
+        </BorderPane>
+    </center>
+</BorderPane>
Index: src/main/java/logic/tiles/HonorTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.tiles;\r\n\r\nimport logic.players.GameRole;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class HonorTile implements Tile,Comparable<Tile>{\r\n    private final String type;\r\n    private final int magnitude;\r\n    private final int number;\r\n    private String owner;\r\n    private boolean flowerState;\r\n\r\n    public HonorTile(String type,int number){\r\n        this.type = type;\r\n        this.magnitude = 0;\r\n        this.number = number;\r\n        this.owner = \"Library\";\r\n        this.flowerState = false;\r\n    }\r\n\r\n    @Override\r\n    public boolean equal(Tile otherTile) {\r\n        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();\r\n    }\r\n\r\n    @Override\r\n    public void changeOwner(GameRole otherOwner) {\r\n        owner = otherOwner.getName();\r\n    }\r\n    @Override\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    @Override\r\n    public int getMagnitude() {\r\n        return magnitude;\r\n    }\r\n\r\n    @Override\r\n    public int getNumber() {\r\n        return number;\r\n    }\r\n\r\n    @Override\r\n    public String getOwner() {\r\n        return owner;\r\n    }\r\n\r\n    @Override\r\n    public boolean getFlowerState() {\r\n        return flowerState;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Tile o) {\r\n        return Integer.compare(this.magnitude,o.getMagnitude());\r\n    }\r\n    public String toString(){\r\n        return type;\r\n        //return type + \" \" + magnitude + \" \" + number + \" \" + owner + \" \" + flowerState;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/HonorTile.java b/src/main/java/logic/tiles/HonorTile.java
--- a/src/main/java/logic/tiles/HonorTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/tiles/HonorTile.java	(date 1717883763431)
@@ -1,64 +1,23 @@
 package logic.tiles;
 
-import logic.players.GameRole;
-
-import java.util.Objects;
 
-public class HonorTile implements Tile,Comparable<Tile>{
-    private final String type;
-    private final int magnitude;
-    private final int number;
-    private String owner;
-    private boolean flowerState;
+import java.io.Serial;
 
-    public HonorTile(String type,int number){
-        this.type = type;
-        this.magnitude = 0;
-        this.number = number;
-        this.owner = "Library";
-        this.flowerState = false;
-    }
-
-    @Override
-    public boolean equal(Tile otherTile) {
-        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();
-    }
-
-    @Override
-    public void changeOwner(GameRole otherOwner) {
-        owner = otherOwner.getName();
-    }
-    @Override
-    public String getType() {
-        return type;
-    }
+public class HonorTile extends NonSequenceDecorator{
+    @Serial
+    private static final long serialVersionUID = 7L;
+    // Red White Green East West South North
+    public HonorTile(String type) {
+        super(type,new Tile() {
+            @Override
+            public int compareTo(Tile o) {
+                return CharSequence.compare(this.getType(), o.getType());
+            }
 
-    @Override
-    public int getMagnitude() {
-        return magnitude;
-    }
-
-    @Override
-    public int getNumber() {
-        return number;
+            @Override
+            public int getMagnitude() {
+                return -1;
+            }
+        });
     }
-
-    @Override
-    public String getOwner() {
-        return owner;
-    }
-
-    @Override
-    public boolean getFlowerState() {
-        return flowerState;
-    }
-
-    @Override
-    public int compareTo(Tile o) {
-        return Integer.compare(this.magnitude,o.getMagnitude());
-    }
-    public String toString(){
-        return type;
-        //return type + " " + magnitude + " " + number + " " + owner + " " + flowerState;
-    }
 }
Index: src/main/resources/com/mahjong/client/gameRoomWait.fxml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/com/mahjong/client/gameRoomWait.fxml b/src/main/resources/com/mahjong/client/gameRoomWait.fxml
new file mode 100644
--- /dev/null	(date 1717879372556)
+++ b/src/main/resources/com/mahjong/client/gameRoomWait.fxml	(date 1717879372556)
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<?import javafx.geometry.Insets?>
+<?import javafx.scene.control.Button?>
+<?import javafx.scene.control.Label?>
+<?import javafx.scene.layout.VBox?>
+<?import javafx.scene.text.Font?>
+
+<VBox fx:id="vBox" alignment="CENTER" spacing="20.0" xmlns="http://javafx.com/javafx/21" xmlns:fx="http://javafx.com/fxml/1" fx:controller="com.mahjong.client.WaitRoomController">
+    <VBox.margin>
+        <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
+    </VBox.margin>
+    <Label text="Waiting joining...">
+      <font>
+         <Font size="30.0" />
+      </font></Label>
+    <Button fx:id="returnButton" onAction="#handleReturn" text="Back">
+      <font>
+         <Font size="20.0" />
+      </font></Button>
+</VBox>
Index: src/main/java/logic/tiles/BambooTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.tiles;\r\n\r\nimport logic.players.GameRole;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class BambooTile implements Tile,Comparable<Tile>{\r\n    private final String type;\r\n    private final int magnitude;\r\n    private final int number;\r\n    private String owner;\r\n    private boolean flowerState;\r\n\r\n    public BambooTile(String type,int magnitude,int number){\r\n        this.type = type;\r\n        this.magnitude = magnitude;\r\n        this.number = number;\r\n        this.owner = \"Library\";\r\n        this.flowerState = false;\r\n    }\r\n\r\n    @Override\r\n    public boolean equal(Tile otherTile) {\r\n        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();\r\n    }\r\n\r\n    @Override\r\n    public void changeOwner(GameRole otherOwner) {\r\n        owner = otherOwner.getName();\r\n    }\r\n\r\n    @Override\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    @Override\r\n    public int getMagnitude() {\r\n        return magnitude;\r\n    }\r\n\r\n    @Override\r\n    public int getNumber() {\r\n        return number;\r\n    }\r\n\r\n    @Override\r\n    public String getOwner() {\r\n        return owner;\r\n    }\r\n\r\n    @Override\r\n    public boolean getFlowerState() {\r\n        return flowerState;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Tile o) {\r\n        return Integer.compare(this.magnitude,o.getMagnitude());\r\n    }\r\n\r\n    public String toString(){\r\n        return type + \" \" + magnitude;\r\n        //return type + \" \" + magnitude + \" \" + number + \" \" + owner + \" \" + flowerState;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/BambooTile.java b/src/main/java/logic/tiles/BambooTile.java
--- a/src/main/java/logic/tiles/BambooTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/tiles/BambooTile.java	(date 1717779668451)
@@ -1,66 +1,23 @@
 package logic.tiles;
 
-import logic.players.GameRole;
-
-import java.util.Objects;
 
-public class BambooTile implements Tile,Comparable<Tile>{
-    private final String type;
-    private final int magnitude;
-    private final int number;
-    private String owner;
-    private boolean flowerState;
+import java.io.Serial;
 
-    public BambooTile(String type,int magnitude,int number){
-        this.type = type;
-        this.magnitude = magnitude;
-        this.number = number;
-        this.owner = "Library";
-        this.flowerState = false;
-    }
-
-    @Override
-    public boolean equal(Tile otherTile) {
-        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();
-    }
-
-    @Override
-    public void changeOwner(GameRole otherOwner) {
-        owner = otherOwner.getName();
-    }
+public class BambooTile extends SequenceDecorator{
+    @Serial
+    private static final long serialVersionUID = 4L;
+    public BambooTile(int magnitude){
+        super("Bamboo",magnitude,new Tile() {
+            @Override
+            public int compareTo(Tile other) {
+                return Integer.compare(this.getMagnitude(), other.getMagnitude());
+
+            }
 
-    @Override
-    public String getType() {
-        return type;
-    }
-
-    @Override
-    public int getMagnitude() {
-        return magnitude;
-    }
-
-    @Override
-    public int getNumber() {
-        return number;
+            @Override
+            public int getMagnitude() {
+                return magnitude;
+            }
+        });
     }
-
-    @Override
-    public String getOwner() {
-        return owner;
-    }
-
-    @Override
-    public boolean getFlowerState() {
-        return flowerState;
-    }
-
-    @Override
-    public int compareTo(Tile o) {
-        return Integer.compare(this.magnitude,o.getMagnitude());
-    }
-
-    public String toString(){
-        return type + " " + magnitude;
-        //return type + " " + magnitude + " " + number + " " + owner + " " + flowerState;
-    }
 }
Index: src/main/java/logic/tiles/DotTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.tiles;\r\n\r\nimport logic.players.GameRole;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class DotTile implements Tile,Comparable<Tile>{\r\n    private final String type;\r\n    private final int magnitude;\r\n    private final int number;\r\n    private String owner;\r\n    private boolean flowerState;\r\n\r\n    public DotTile(String type,int magnitude,int number){\r\n        this.type = type;\r\n        this.magnitude = magnitude;\r\n        this.number = number;\r\n        this.owner = \"Library\";\r\n        this.flowerState = false;\r\n    }\r\n\r\n    @Override\r\n    public boolean equal(Tile otherTile) {\r\n        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();\r\n    }\r\n\r\n    @Override\r\n    public void changeOwner(GameRole otherOwner) {\r\n        owner = otherOwner.getName();\r\n    }\r\n\r\n    @Override\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    @Override\r\n    public int getMagnitude() {\r\n        return magnitude;\r\n    }\r\n\r\n    @Override\r\n    public int getNumber() {\r\n        return number;\r\n    }\r\n\r\n    @Override\r\n    public String getOwner() {\r\n        return owner;\r\n    }\r\n\r\n    @Override\r\n    public boolean getFlowerState() {\r\n        return flowerState;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Tile o) {\r\n        return Integer.compare(this.magnitude,o.getMagnitude());\r\n    }\r\n\r\n    public String toString(){\r\n        return type + \" \" + magnitude;\r\n        //return type + \" \" + magnitude + \" \" + number + \" \" + owner + \" \" + flowerState;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/DotTile.java b/src/main/java/logic/tiles/DotTile.java
--- a/src/main/java/logic/tiles/DotTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/tiles/DotTile.java	(date 1717779668341)
@@ -1,66 +1,23 @@
 package logic.tiles;
 
-import logic.players.GameRole;
-
-import java.util.Objects;
 
-public class DotTile implements Tile,Comparable<Tile>{
-    private final String type;
-    private final int magnitude;
-    private final int number;
-    private String owner;
-    private boolean flowerState;
 
-    public DotTile(String type,int magnitude,int number){
-        this.type = type;
-        this.magnitude = magnitude;
-        this.number = number;
-        this.owner = "Library";
-        this.flowerState = false;
-    }
+import java.io.Serial;
 
-    @Override
-    public boolean equal(Tile otherTile) {
-        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();
-    }
-
-    @Override
-    public void changeOwner(GameRole otherOwner) {
-        owner = otherOwner.getName();
-    }
+public class DotTile extends SequenceDecorator {
+    @Serial
+    private static final long serialVersionUID = 6L;
+    public DotTile(int magnitude){
+        super("Dot",magnitude,new Tile() {
+            @Override
+            public int compareTo(Tile other) {
+                return Integer.compare(this.getMagnitude(), other.getMagnitude());
+            }
 
-    @Override
-    public String getType() {
-        return type;
-    }
-
-    @Override
-    public int getMagnitude() {
-        return magnitude;
-    }
-
-    @Override
-    public int getNumber() {
-        return number;
+            @Override
+            public int getMagnitude() {
+                return magnitude;
+            }
+        });
     }
-
-    @Override
-    public String getOwner() {
-        return owner;
-    }
-
-    @Override
-    public boolean getFlowerState() {
-        return flowerState;
-    }
-
-    @Override
-    public int compareTo(Tile o) {
-        return Integer.compare(this.magnitude,o.getMagnitude());
-    }
-
-    public String toString(){
-        return type + " " + magnitude;
-        //return type + " " + magnitude + " " + number + " " + owner + " " + flowerState;
-    }
 }
Index: src/main/java/logic/tiles/NonSequenceDecorator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/NonSequenceDecorator.java b/src/main/java/logic/tiles/NonSequenceDecorator.java
new file mode 100644
--- /dev/null	(date 1717883763423)
+++ b/src/main/java/logic/tiles/NonSequenceDecorator.java	(date 1717883763423)
@@ -0,0 +1,30 @@
+package logic.tiles;
+
+import java.io.Serial;
+
+abstract class NonSequenceDecorator extends Tile implements Comparable<Tile> {
+    @Serial
+    private static final long serialVersionUID = 3L;
+    private Tile tile;
+    // Red White Green East West South North
+    public NonSequenceDecorator(String type,Tile tile){
+        this.tile = tile;
+        this.tile.setType(type);
+    }
+    @Override
+    public String getType() {
+        return tile.getType();
+    }
+    @Override
+    public int getMagnitude(){
+        return -1;
+    }
+    @Override
+    public String toString(){
+        return tile.getType();
+    }
+    @Override
+    public int compareTo(Tile other) {
+        return CharSequence.compare(this.getType(), other.getType());
+    }
+}
Index: src/main/java/logic/tiles/CharacterTile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.tiles;\r\n\r\nimport logic.players.GameRole;\r\n\r\nimport java.util.Objects;\r\n\r\npublic class CharacterTile implements Tile,Comparable<CharacterTile>{\r\n    private final String type;\r\n    private final int magnitude;\r\n    private final int number;\r\n    private String owner;\r\n    private boolean flowerState;\r\n\r\n    public CharacterTile(String type,int magnitude,int number){\r\n        this.type = type;\r\n        this.magnitude = magnitude;\r\n        this.number = number;\r\n        this.owner = \"Library\";\r\n        this.flowerState = false;\r\n    }\r\n\r\n    @Override\r\n    public boolean equal(Tile otherTile) {\r\n        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();\r\n    }\r\n\r\n    @Override\r\n    public void changeOwner(GameRole otherOwner) {\r\n        owner = otherOwner.getName();\r\n    }\r\n\r\n    @Override\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    @Override\r\n    public int getMagnitude() {\r\n        return magnitude;\r\n    }\r\n\r\n    @Override\r\n    public int getNumber() {\r\n        return number;\r\n    }\r\n\r\n    @Override\r\n    public String getOwner() {\r\n        return owner;\r\n    }\r\n\r\n    @Override\r\n    public boolean getFlowerState() {\r\n        return flowerState;\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(CharacterTile o) {\r\n        return Integer.compare(this.magnitude,o.getMagnitude());\r\n    }\r\n\r\n    public String toString(){\r\n        return type + \" \" + magnitude;\r\n        //return type + \" \" + magnitude + \" \" + number + \" \" + owner + \" \" + flowerState;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/CharacterTile.java b/src/main/java/logic/tiles/CharacterTile.java
--- a/src/main/java/logic/tiles/CharacterTile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/tiles/CharacterTile.java	(date 1717779668425)
@@ -1,66 +1,22 @@
 package logic.tiles;
 
-import logic.players.GameRole;
-
-import java.util.Objects;
 
-public class CharacterTile implements Tile,Comparable<CharacterTile>{
-    private final String type;
-    private final int magnitude;
-    private final int number;
-    private String owner;
-    private boolean flowerState;
+import java.io.Serial;
 
-    public CharacterTile(String type,int magnitude,int number){
-        this.type = type;
-        this.magnitude = magnitude;
-        this.number = number;
-        this.owner = "Library";
-        this.flowerState = false;
-    }
-
-    @Override
-    public boolean equal(Tile otherTile) {
-        return Objects.equals(type, otherTile.getType()) && magnitude == otherTile.getMagnitude();
-    }
-
-    @Override
-    public void changeOwner(GameRole otherOwner) {
-        owner = otherOwner.getName();
-    }
+public class CharacterTile extends SequenceDecorator{
+    @Serial
+    private static final long serialVersionUID = 5L;
+    public CharacterTile(int magnitude) {
+        super("Character", magnitude,new Tile() {
+            @Override
+            public int compareTo(Tile other) {
+                return Integer.compare(this.getMagnitude(), other.getMagnitude());
+            }
 
-    @Override
-    public String getType() {
-        return type;
-    }
-
-    @Override
-    public int getMagnitude() {
-        return magnitude;
-    }
-
-    @Override
-    public int getNumber() {
-        return number;
+            @Override
+            public int getMagnitude() {
+                return magnitude;
+            }
+        });
     }
-
-    @Override
-    public String getOwner() {
-        return owner;
-    }
-
-    @Override
-    public boolean getFlowerState() {
-        return flowerState;
-    }
-
-    @Override
-    public int compareTo(CharacterTile o) {
-        return Integer.compare(this.magnitude,o.getMagnitude());
-    }
-
-    public String toString(){
-        return type + " " + magnitude;
-        //return type + " " + magnitude + " " + number + " " + owner + " " + flowerState;
-    }
 }
Index: src/main/java/logic/tiles/Tile.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package logic.tiles;\r\n\r\nimport logic.players.GameRole;\r\n\r\npublic interface Tile {\r\n    String getType();\r\n    int getMagnitude();\r\n    int getNumber();\r\n    String getOwner();\r\n    boolean getFlowerState();\r\n    boolean equal(Tile otherTile);\r\n    void changeOwner(GameRole gameRole);\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/Tile.java b/src/main/java/logic/tiles/Tile.java
--- a/src/main/java/logic/tiles/Tile.java	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/src/main/java/logic/tiles/Tile.java	(date 1717779668367)
@@ -1,14 +1,18 @@
 package logic.tiles;
 
-import logic.players.GameRole;
+import java.io.Serial;
+import java.io.Serializable;
 
-public interface Tile {
-    String getType();
-    int getMagnitude();
-    int getNumber();
-    String getOwner();
-    boolean getFlowerState();
-    boolean equal(Tile otherTile);
-    void changeOwner(GameRole gameRole);
+public abstract class Tile implements Serializable,Comparable<Tile>{
+    @Serial
+    private static final long serialVersionUID = 1L;
+    private String type;
+    public void setType(String type){
+        this.type = type;
+    }
+    public String getType() {
+        return type;
+    }
+    public abstract int getMagnitude();
 
 }
Index: src/main/java/logic/tiles/SequenceDecorator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/logic/tiles/SequenceDecorator.java b/src/main/java/logic/tiles/SequenceDecorator.java
new file mode 100644
--- /dev/null	(date 1717883763412)
+++ b/src/main/java/logic/tiles/SequenceDecorator.java	(date 1717883763412)
@@ -0,0 +1,34 @@
+package logic.tiles;
+
+import java.io.Serial;
+import java.io.Serializable;
+
+abstract class SequenceDecorator extends Tile implements Serializable, Comparable<Tile>{
+    @Serial
+    private static final long serialVersionUID = 2L;
+    private Tile tile;
+
+    private int magnitude;
+    // Character, Bamboo, Dot
+    public SequenceDecorator(String type,int magnitude,Tile tile){
+        this.tile = tile;
+        this.magnitude = magnitude;
+        this.tile.setType(type);
+    }
+    @Override
+    public String getType() {
+        return tile.getType();
+    }
+    @Override
+    public int getMagnitude(){
+        return magnitude;
+    }
+    @Override
+    public String toString(){
+        return magnitude+tile.getType();
+    }
+    @Override
+    public int compareTo(Tile other) {
+        return Integer.compare(this.getMagnitude(), other.getMagnitude());
+    }
+}
Index: pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.example</groupId>\r\n    <artifactId>Mahjong</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n    <name>Mahjong</name>\r\n\r\n    <properties>\r\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\r\n        <junit.version>5.9.2</junit.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-controls</artifactId>\r\n            <version>17.0.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-fxml</artifactId>\r\n            <version>17.0.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-web</artifactId>\r\n            <version>17.0.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.openjfx</groupId>\r\n            <artifactId>javafx-media</artifactId>\r\n            <version>17.0.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.controlsfx</groupId>\r\n            <artifactId>controlsfx</artifactId>\r\n            <version>11.1.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.dlsc.formsfx</groupId>\r\n            <artifactId>formsfx-core</artifactId>\r\n            <version>11.6.0</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.openjfx</groupId>\r\n                    <artifactId>*</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>net.synedra</groupId>\r\n            <artifactId>validatorfx</artifactId>\r\n            <version>0.4.0</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.openjfx</groupId>\r\n                    <artifactId>*</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.kordamp.ikonli</groupId>\r\n            <artifactId>ikonli-javafx</artifactId>\r\n            <version>12.3.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.kordamp.bootstrapfx</groupId>\r\n            <artifactId>bootstrapfx-core</artifactId>\r\n            <version>0.4.0</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>eu.hansolo</groupId>\r\n            <artifactId>tilesfx</artifactId>\r\n            <version>17.1.17</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.openjfx</groupId>\r\n                    <artifactId>*</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.github.almasb</groupId>\r\n            <artifactId>fxgl</artifactId>\r\n            <version>17.2</version>\r\n            <exclusions>\r\n                <exclusion>\r\n                    <groupId>org.openjfx</groupId>\r\n                    <artifactId>*</artifactId>\r\n                </exclusion>\r\n            </exclusions>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.junit.jupiter</groupId>\r\n            <artifactId>junit-jupiter-api</artifactId>\r\n            <version>${junit.version}</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.junit.jupiter</groupId>\r\n            <artifactId>junit-jupiter-engine</artifactId>\r\n            <version>${junit.version}</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-compiler-plugin</artifactId>\r\n                <version>3.11.0</version>\r\n                <configuration>\r\n                    <source>17</source>\r\n                    <target>17</target>\r\n                </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.openjfx</groupId>\r\n                <artifactId>javafx-maven-plugin</artifactId>\r\n                <version>0.0.8</version>\r\n                <executions>\r\n                    <execution>\r\n                        <!-- Default configuration for running with: mvn clean javafx:run -->\r\n                        <id>default-cli</id>\r\n                        <configuration>\r\n                            <mainClass>com.example.mahjong/com.example.mahjong.Client</mainClass>\r\n                            <launcher>app</launcher>\r\n                            <jlinkZipName>app</jlinkZipName>\r\n                            <jlinkImageName>app</jlinkImageName>\r\n                            <noManPages>true</noManPages>\r\n                            <stripDebug>true</stripDebug>\r\n                            <noHeaderFiles>true</noHeaderFiles>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pom.xml b/pom.xml
--- a/pom.xml	(revision 7bc1b62f7260f350d589f1b1cdee467de41f092f)
+++ b/pom.xml	(date 1717880153310)
@@ -16,6 +16,26 @@
 
     <dependencies>
         <dependency>
+            <groupId>eu.hansolo.fx</groupId>
+            <artifactId>countries</artifactId>
+            <version>17.0.23</version>
+        </dependency>
+        <dependency>
+            <groupId>eu.hansolo.fx</groupId>
+            <artifactId>heatmap</artifactId> <!-- 假设 artifactId 是 'heatmap' -->
+            <version>17.0.12</version>
+        </dependency>
+        <dependency>
+            <groupId>eu.hansolo</groupId>
+            <artifactId>toolboxfx</artifactId>
+            <version>17.0.33</version>
+        </dependency>
+        <dependency>
+            <groupId>eu.hansolo</groupId>
+            <artifactId>toolbox</artifactId>
+            <version>17.0.35</version>
+        </dependency>
+        <dependency>
             <groupId>org.openjfx</groupId>
             <artifactId>javafx-controls</artifactId>
             <version>17.0.6</version>
@@ -106,9 +126,35 @@
             <version>${junit.version}</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.openjfx</groupId>
+            <artifactId>javafx-base</artifactId>
+            <version>17.0.6</version>
+        </dependency>
+        <dependency>
+            <groupId>org.openjfx</groupId>
+            <artifactId>javafx-graphics</artifactId>
+            <version>17.0.6</version>
+        </dependency>
+        <dependency>
+            <groupId>org.testng</groupId>
+            <artifactId>testng</artifactId>
+            <version>RELEASE</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <build>
+        <resources>
+            <resource>
+                <directory>src/main/resources</directory>
+                <includes>
+                    <include>**/*.png</include>
+                    <include>**/*.fxml</include>
+                    <include>**/*.mp3</include>
+                </includes>
+            </resource>
+        </resources>
         <plugins>
             <plugin>
                 <groupId>org.apache.maven.plugins</groupId>
@@ -128,7 +174,7 @@
                         <!-- Default configuration for running with: mvn clean javafx:run -->
                         <id>default-cli</id>
                         <configuration>
-                            <mainClass>com.example.mahjong/com.example.mahjong.Client</mainClass>
+                            <mainClass>com.example.mahjong/com.mahjong.client.Client</mainClass>
                             <launcher>app</launcher>
                             <jlinkZipName>app</jlinkZipName>
                             <jlinkImageName>app</jlinkImageName>
